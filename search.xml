<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/posts/840f3c156380/"/>
      <url>/posts/840f3c156380/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>V8 如何执行一段JS代码？</h1><p>V8出现之前，所有的JS虚拟机所采用的都是<strong>解释执行</strong>的方式，这就是JS执行速度过慢的一个主要原因。<br>V8 引擎引入<strong>即时编译（JIT）<strong>的双轮驱动的设计，这样一种权衡策略，混合了</strong>编译执行</strong>和<strong>解释执行</strong>两种手段，极大地提升了JS的执行速度。</p><p>而且V8也早于其他虚拟机引入了<strong>惰性编译、内联缓存、隐藏类</strong>等机制，对于JS代码的编译执行效率进一步优化。</p><h2 id="V8-执行JS代码的主要流程">V8 执行JS代码的主要流程</h2><ol><li>初始化基础环境</li><li>解析源码生成AST和作用域</li><li>依赖AST和作用域生成字节码</li><li>解释执行字节码</li><li>监听热点代码</li><li>优化热点代码为二进制的机器代码</li><li>反优化生成的机器代码</li></ol><p>※ 了解几个名词：</p><ul><li>隐藏类：用来将JS中动态类型转为静态类型。可以消除动态类型的语言执行速度过慢的问题。</li><li>惰性解析：目的是为了<strong>加速代码的启动速度</strong>。</li><li>V8事件循环系统：与JS中的异步编程特性密切相关。JS是单线程的，JS代码都是在一个线程上执行。如果同一时间发送了多个JS执行的请求，就需要排队，即进行异步编程。V8事件循环系统会调度这些排队任务，保证JS代码被V8有序执行，因此，事件循环系统就是V8的心脏，驱动V8的持续工作。</li><li>垃圾回收机制：自动垃圾回收是一种在堆内存中找出哪些对象在被使用，还有哪些对象没被使用，并且将后者删掉的机制。所谓使用中的对象（已引用对象），是指程序中有指针指向的对象；而未使用中的对象（未引用对象），则没有被任何指针给指向，因此占用的内存也可以被回收。JS是一种自动垃圾回收的语言。</li></ul><h1>JS 与 V8</h1><h2 id="一等公民">一等公民</h2><p><strong>一等公民</strong>可以作为函数参数，可以作为函数返回值，也可以赋值给变量。<br><em>如果某个编程语言的函数，可以合这个语言的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民。</em><br>🌰栗子：<br>字符串在几乎所有编程语言中都是一等公民，字符串可以作为函数参数，字符串可以作为函数返回值，字符串也可以赋值给变量。对于各种编程语言来说，函数就不一定是一等公民了，比如java8之前的版本。<br>对于JS来说，函数可以赋值给变量，也可以作为函数参数，还可以作为函数返回值，因此JS中函数是一等公民。</p><h2 id="动态作用域和静态作用域">动态作用域和静态作用域</h2><ul><li>作用域：作用域是一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识名称进行变量查找。</li><li>静态作用域：又称词法作用域，函数的作用域在函数定义时就决定了，通俗点就是你在写代码的时候将变量和块作用域写在哪里决定了。</li><li>动态作用域：函数的作用域在函数调用时才决定的。</li></ul><p>JS采用的是静态作用域，函数定义的位置就决定了函数的作用域。</p><h2 id="闭包的三个基本特性">闭包的三个基本特性</h2><ul><li>JS语言允许在函数内部定义新的函数</li><li>可以在内部函数中访问父函数中定义的变量</li><li>因为JS中的函数是一等公民，所以函数可以作为另一个函数的返回值。</li></ul><h2 id="惰性解析">惰性解析</h2><blockquote><p>惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成AST和字节码，而仅仅生成顶层代码的AST和字节码。</p></blockquote><p>在编译JS代码过程中，V8并不会一次将所有的JS解析为中间代码，主要是基于以下两点：</p><ol><li>如果一次解析和编译所有的JS代码，过多的代码会增加编译时间，严重影响到首次执行JS代码的速度，让用户感觉到卡顿。因为有时一个页面的JS代码很大，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；</li><li>解析完成的字节码和编译后的机器代码都会存放在内存中，如果一次性解析和编译所有JS代码，那么这些中间代码和机器代码将会一直占用内存。</li></ol><p>基于以上原因，所有主流的JS虚拟机都实现了惰性解析。</p><h2 id="预解析器">预解析器</h2><p>V8引入预解析器，当解析顶层代码时，遇到了一个函数，那么预解析器不会跳过该函数，而是对该函数做一次快速的预解析。</p><ol><li>判断当前函数是否存在一些语法上的错误，发现了语法错误，那么就会向V8抛出错误；</li><li>检查函数是否存在一些语法上的错误，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。</li></ol><h2 id="V8-内部如何存储对象：快属性和满属性">V8 内部如何存储对象：快属性和满属性</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS垃圾回收机制</title>
      <link href="/posts/e6823bff44e2/"/>
      <url>/posts/e6823bff44e2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><strong>内存溢出</strong>：程序运行出现的错误，就像水杯，满了之后再加水就溢出了。同理，内存溢出就是程序运行所需的内存大于可用内存，就出现内存溢出错误。</p><blockquote><p>例子：写一个千万级别的循环，然后用浏览器打开，浏览器就会非常卡，甚至直接报错内存不足，崩溃了。不同浏览器有不同的表现。</p></blockquote><p><strong>产生原因</strong>：内存溢出一般是<strong>内存泄漏</strong>造成的，占用的内存不需要用到了，但是没有及时释放。内存泄漏积累的多了轻则会系统性能，重则直接引起内存溢出系统崩溃。</p><h3 id="哪些场景会引发内存泄漏？">哪些场景会引发内存泄漏？</h3><ol><li>全局变量引起的内存泄漏：</li></ol><p>根据 JS 的垃圾回收机制，全局变量不会被回收，所以一些意外的、不需要的全局变量多了，没有释放，就造成了内存泄漏。</p><ol start="2"><li><a href="https://blog.csdn.net/qq_45479404/article/details/124843856">闭包</a>：</li></ol><p>内部的变量因为被闭包引用得不到释放，会造成内存泄漏。因此我们在开发过程中，尽量不要使用闭包。</p><ol start="3"><li>计时器、回调、监听等事件没有移除：</li></ol><p>这些事件没有移除是一直存在的，一直存在没有被释放就会造成内存泄漏。</p><ol start="4"><li>给 DOM 添加属性或方法：</li></ol><p>给 DOM 添加属性或方法等，也会造成变量引用得不到释放，造成内存泄漏。<br>最核心的：由于垃圾回收机制，全局变量或者是被全局变量引用，垃圾回收机制就无法回收。如果一些用完一次就不再使用的没有释放，那么积累的多了，就容易造成内存溢出。</p><h3 id="JS-内存管理">JS 内存管理</h3><ol><li>分配给<code>使用者</code>所需的内存</li><li><code>使用者</code>拿到这些内存，并使用内存</li><li><code>使用者</code>不需要这些内存了，释放并归还给系统</li></ol><p>变量就是<code>使用者</code>。</p><blockquote><p>JS 数据类型分为；基本数据类型 和 引用数据类型。</p><ul><li>基本数据类型：大小固定，值保存在<code>栈内存</code>中，可通过值直接访问。</li><li>引用数据类型：大小不固定（∵ 可加属性），<code>栈内存</code>中存着指针，指向<code>堆内存</code>中的对象空间， 通过引用来访问。</li></ul></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670837158434-d02b829e-2ca6-4457-9178-7e528051eba5.png#averageHue=%23fcf9f8&amp;clientId=u8f053162-afe4-4&amp;from=paste&amp;height=356&amp;id=ua3796757&amp;originHeight=356&amp;originWidth=885&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25990&amp;status=done&amp;style=none&amp;taskId=uaadda59b-863b-401d-993c-56443f41c76&amp;title=&amp;width=885" alt="image.png"></p><ul><li>栈内存的内存都是<code>操作系统自动分配和释放回收的</code>（由于栈内存所存的基础数据类型大小是固定的）</li><li>JS 堆内存需要 JS 引擎手动释放这些内存（由于堆内存所存大小不固定，系统无法自动释放回收）</li></ul><h3 id="为什么要进行垃圾回收？">为什么要进行垃圾回收？</h3><p>在 Chrome 中，V8 被限制了内存的使用（64 位约 1.4G/1464MB，32 位约 0.7G/732MB）。<br>限制内存使用的原因：</p><ul><li>表层：V8 最初为浏览器而设计，不太可能遇到用大量内存的场景</li><li>深层：V8 的垃圾回收机制的限制（如果清理大量的内存垃圾很耗时间，这样会引起 JS 线程暂时执行的时间，性能和应用直线下降）<blockquote><p>当我们的代码没有按照正确的写法时，会使得 JS 引擎的垃圾回收机制无法正确的对内存进行释放（内存泄漏），从而使得浏览器占用的内存不断增加，进而导致 JS 和应用、操作系统性能下降。</p></blockquote></li></ul><h3 id="V8-的垃圾回收算法">V8 的垃圾回收算法</h3><h4 id="分代回收">分代回收</h4><p>在 JS 中，对象存活周期分为两种情况：</p><ul><li>存活周期很短：经过一次垃圾回收后，就被释放回收掉。</li><li>存活周期很长：经过多次垃圾回收后，还存在。</li></ul><p>产生问题：对于存活周期长的，多次回收都回收不掉，明知回收不掉，却还不断地去回收，不是很消耗性能吗？<br>对于此问题，V8 做了<strong>分代回收</strong>的优化方法。即：<strong>V8 将堆分为两个空间，一个叫新生代，一个叫老生代。新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方。</strong></p><blockquote><p>新生代容量：1-8M。而老生代容量很大。对于这两块区域，V8 分别做了<strong>不同的垃圾回收器和不同的垃圾回收算法</strong>，以致于更高效地进行垃圾回收。</p><ul><li>副垃圾回收器 + Scavenge 算法：主要负责新生代的垃圾回收</li><li>主垃圾回收器 + Mark-Sweep &amp;&amp; Mark-Compact 算法</li></ul></blockquote><h5 id="新生代">新生代</h5><p>在 JS 中，任何对象的声明分配到的内存，将会先放到新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。在新生代中，主要使用 Scavenge 算法进行垃圾回收，Scavenge 算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。<br>Scavange 算法将新生代堆分为两部分，分别叫 from-space 和 to-space，工作方式也很简单，就是将 from-space 中存活的活动对象复制到 to-space 中，并将这些对象的内存有序排列起来，然后将 from-space 中的非活动对象的内存进行释放，完成后，将 from space 和 to space 进行互换，这样可以使得新生代中的这两块区域可以重复利用。<br>具体步骤：</p><ol><li>标记活动对象和非活动对象</li><li>复制 from-space 的活动对象到 to-space 中并进行排序</li><li>清除 from-space 中的非活动对象</li><li>将 from-space 和 to-space 进行角色互换，以便下一次的 Scavenge 算法垃圾回收<blockquote><p>垃圾回收器如何知道哪些是活动对象，哪些是非活动对象呢？</p><ul><li>从初始的根对象（window 或 global）的指针开始，向下搜索子节点，子节点就被搜索到了，说明该子节点的引用对象可达，并为其进行标记。</li><li>然后接着递归搜索，直到所有的子节点被遍历结束。</li><li>那么没有被遍历到的节点，就没有标记，也就会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。</li></ul></blockquote></li></ol><p>💬 新生代中的对象什么时候变成老生代？<br>在新生代中，还进一步进行了细分。分为 nursery 子代 和 intermediate 子代 两个区域，一个对象第一次分配内存时会被分配到新生代中的 nursery 子代，如果经过下一次的垃圾回收这个对象还存在新生代中，这时，我们将此对象移动到 intermedidate 子代，在经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器 会将该对象移动到老生代中，这个移动的过程被称为<strong>晋升</strong>。</p><h5 id="老生代">老生代</h5><p>老生代空间：新生代空间的对象，身经百战后，留下来的老对象，成功晋升到了老生代中。<br>由于这些对象都是经过多次回收过程但是没有被回收走的，都是一群生命力顽强、存活率高的对象，所以老生代中，回收算法不宜使用 Scavenge 算法。<br>原因：</p><ul><li>Scavenge 算法是复制算法，反复复制这些存活率高的对象，没有什么意义，效率极低。</li><li>Scavenge 算法是以空间换时间的算法，老生代是内存很大的空间，如果使用 Scavenge 算法，空间资源非常浪费。</li></ul><p>因此，老生代里使用了 Mark-Sweep 算法（标记清理）和 Mark-Compact 算法（标记整理）。<br><strong>Mark-Sweep（标记清理）</strong><br>Mark-Sweep 分为两个阶段，标记和清理阶段，之前的 Scavenge 算法 也有标记和清理，但是 Mark-Sweep 算法跟 Scavenge 算法的区别是，后者需要复制再清理，前者不需要，Mark-Sweep 直接标记活动对象和非活动对象之后，就直接执行清理了。</p><ul><li>标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记</li><li>清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象。</li></ul><p><strong>Mark-Compact（标记整理）</strong><br>Mark-Sweep 算法执行垃圾回收之后，留下了很多零零散散的空位。坏处：如果此时进来了一个大对象，需要对此对象分配一个大内存，先从零零散散的空位中找位置，找了一圈，发现没有适合自己大小的空位，只好拼在了最后，这个寻找空位的过程是耗性能的，这也是 Mark-Sweep 算法的一个缺点。<br>Mark-Compact 算法是 Mark-Sweep 算法的加强版，在 Mark-Sweep 算法的基础上，加上了<code>整理阶段</code>，每次清理完非活动对象，就会把剩下的活动对象，整理到内存的一侧，整理完成后，直接回收掉边界上的内存。</p><h4 id="全停顿（Stop-The-World）">全停顿（Stop-The-World）</h4><p>JS 代码的运行要用到 JS 引擎，垃圾回收也要用到 JS 引擎，如果这两者同时进行了，发生冲突了，怎么办？答案：垃圾回收优先于代码执行，会先停止代码的执行，等到垃圾回收完毕，再执行 JS 代码。这个过程，成为全停顿。<br>由于新生代空间小，并且存活对象少，再配合 Scavenge 算法，停顿时间较短。但是老生代就不一样了，某些情况活动对象比较多时，停顿时间就会较长，使得页面出现了卡顿现象。</p><h4 id="Orinoco-优化">Orinoco 优化</h4><p>orinoco 是 V8 的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，它提出了增量标记、懒性清理、并发、并行的优化方法。</p><h5 id="增量标记（Incremental-marking）">增量标记（Incremental marking）</h5><p>增量标记是在<code>标记</code>这个阶段进行了优化。<br>当垃圾少量时，不会做增量标记优化，但是当垃圾达到一定数量时，增量标记就会开启：标记一点，JS 代码运行一段，从而提高效率。</p><h5 id="惰性清理（Lazy-sweeping）">惰性清理（Lazy sweeping）</h5><p>惰性清理针对<code>清除</code>阶段。在增量标记后，要进行清理非活动对象时，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让 JS 代码跑起来，所以就<code>延迟了清理</code>，让 JS 代码先执行，或者<code>只清理部分垃圾</code>，而不清理全部。这个优化就叫做<code>惰性清理</code>。<br>整理标记和惰性清理的出现，大大改善了<code>全停顿</code>的现象。但是产生了问题：增量<code>标记是标记一点，JS运行一段</code>。如果你前脚刚标记一个对象为活动对象，后脚 JS 代码就把此对象设置为非活动对象，或者反过来，前脚没有标记一个对象为活动对象，后脚 JS 代码就把此对象设置为活动对象。<br>总结一下就是：标记和代码执行的穿插，有可能造成<code>对象引用改变，标记错误</code>现象。这就需要使用<code>写屏障</code>技术来记录这些引用关系的变化。</p><h5 id="并发（Concurrent）">并发（Concurrent）</h5><p>并发式 GC 允许在垃圾回收时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于 JS 代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行<code>写屏障</code>操作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670851619218-0efd0aee-9227-4585-9745-d95f8bcacd7c.png#averageHue=%23b5e19a&amp;clientId=u8f053162-afe4-4&amp;from=paste&amp;height=147&amp;id=u0aee8473&amp;originHeight=147&amp;originWidth=718&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=56932&amp;status=done&amp;style=none&amp;taskId=u19ceca22-5e5e-4460-bade-47f1ebaf8b4&amp;title=&amp;width=718" alt="image.png"></p><h5 id="并行">并行</h5><p>并行式 GC 运行主线程和辅助线程同时执行同样的 GC 工作，这样可以让辅助线程来分担主线程的 GC 工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670851771272-d5454f1b-90b5-4cbd-83bb-8d1805c9bce1.png#averageHue=%23f6f6f6&amp;clientId=u8f053162-afe4-4&amp;from=paste&amp;height=139&amp;id=ue342693c&amp;originHeight=139&amp;originWidth=608&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=52245&amp;status=done&amp;style=none&amp;taskId=ucd478771-10dc-4006-83a3-1f89d520c4e&amp;title=&amp;width=608" alt="image.png"></p><h3 id="V8-当前的垃圾回收机制">V8 当前的垃圾回收机制</h3><p>2011 年，V8 应用了增量标记机制。2018 年，Chrome64 和 Node.js V10 启动<code>并发（Concurrent）</code>，同时在并发基础上添加<code>并行（Parallel）技术</code>，使得垃圾回收时间大幅度缩短。</p><h4 id="副垃圾回收器">副垃圾回收器</h4><p>V8 在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从 from-to 复制到<code>space-to</code>时，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8 在第一个线程对活动对象进行复制并且复制完成后，都必须去维护这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670852581283-0012ecbd-7021-4bfa-bf9b-64bd4ee61947.png#averageHue=%23f6f6f6&amp;clientId=u8f053162-afe4-4&amp;from=paste&amp;height=142&amp;id=u33593aab&amp;originHeight=142&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=52347&amp;status=done&amp;style=none&amp;taskId=u46c50273-8903-4249-a83f-795e67d5c8a&amp;title=&amp;width=614" alt="image.png"></p><h4 id="主垃圾回收器">主垃圾回收器</h4><p>V8 在老生代垃圾回收中，如果堆中的内存大小超过某个阈值后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，而在 JS 代码执行时，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被 JS 代码修改时，<code>写屏障</code>技术在辅助线程在进行并发标记时进行追踪。<br>当并发标记完成或动态分配的内存达到极限时，主线程会执行最终的快速标记步骤，这时主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行 check 操作，确认操作完成后，某些辅助线程会进行清理内存操作，某些辅助线程会进行内存整理操作，由于都是并发的，并不会影响主线程 JS 代码的执行。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670891665363-ab526d91-530b-485d-a461-ebfd7da717ef.png#averageHue=%23eaf5dc&amp;clientId=u8f053162-afe4-4&amp;from=paste&amp;height=160&amp;id=u97b0bb01&amp;originHeight=160&amp;originWidth=680&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=66145&amp;status=done&amp;style=none&amp;taskId=ua5f38ef3-e648-452a-bada-462d2332057&amp;title=&amp;width=680" alt="image.png"></p><h3 id="问题及解答">问题及解答</h3><h4 id="浏览器怎么进行垃圾回收？">浏览器怎么进行垃圾回收？</h4><blockquote><p>从三个点来回答什么是垃圾、如何捡垃圾、什么时候捡垃圾</p></blockquote><p>什么是垃圾？</p><ol><li>不再需要，即为垃圾</li><li>全局变量随时可能用到，所以一定不是垃圾</li></ol><p>如何捡垃圾（遍历算法）？</p><ol><li>标记空间中「可达」值<ol><li>从根节点（Root）出发，遍历所有的对象</li><li>可以遍历到的对象，是可达的（reachable）</li><li>没有遍历到的对象，不可达的（unreachable）</li></ol></li><li>回收「不可达」的值所占据的内存</li><li>做内存整理</li></ol><p>什么时候捡垃圾？</p><ol><li>前端有其特殊性，垃圾回收时会造成页面卡顿</li><li>分代收集、增量收集、闲时收集</li></ol><h4 id="浏览器中不同类型变量的内存都是何时释放？">浏览器中不同类型变量的内存都是何时释放？</h4><p>JS 中类型：值类型、引用类型</p><ul><li>引用类型<ul><li>在没有引用之后，通过 V8 自动回收</li></ul></li><li>值类型<ul><li>如果处于闭包的情况下，要等闭包没有引用才会被 V8 回收</li><li>非闭包的情况下，等待 V8 的新生代切换时回收</li></ul></li></ul><h4 id="哪些情况会导致内存泄漏？如何避免？">哪些情况会导致内存泄漏？如何避免？</h4><p>内存泄漏是指你「用不到」（访问不到）的变量，依然占据着内存空间，不能被再次利用起来。</p><blockquote><p>以 Vue 为例，通常会有这些情况：</p><ul><li>监听在 window/body 等事件没有解绑</li><li>绑在 EventBus 的事件没有解绑</li><li>Vuex 的$store，watch 了之后没有 unwatch</li><li>使用第三方库创建，没有调用正确的销毁函数</li></ul><p><strong>解决办法：</strong></p><ul><li>beforeDestory 中及时销毁</li><li>绑定了 DOM/BOM 对象 addEventListener，removeEventListener。</li><li>观察者模式 $on，$off 处理</li><li>如果组件中使用了定时器，应销毁处理</li><li>如果在 mouted/created 钩子中使用了第三方库初始化，对应的销毁</li><li>使用弱引用 weakMap、weakSet。</li></ul></blockquote><p>闭包会导致内存泄漏吗？</p><blockquote><p>不会。<br>内存泄漏是指你用不到的（访问不到）的变量，依然占据着空间，不能被再次利用起来。<br>闭包里面的变量就是我们需要的变量，不能说是内存泄漏。<br>只是由于 IE9 之前的版本对 JS 对象和 COM 对象使用不同的垃圾收集，从而导致内存无法回收。这是 IE 的问题，不是闭包的问题。</p></blockquote><h4 id="weakMap-weakSet-Map-Set-有什么区别？">weakMap weakSet Map Set 有什么区别？</h4><p>在 ES6 中为我们新增了两个数据结构 WeakMap、WeakSet ，就是为了解决内存泄漏问题。<br>它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。<br>只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。<br>也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对就就会自动侠消失，不用手动删除引用。</p><h4 id="简单了解浏览器的垃圾回收机制？">简单了解浏览器的垃圾回收机制？</h4><p>浏览器怎么进行垃圾回收？</p><ul><li>思路：什么是垃圾、怎么收垃圾、什么时候收垃圾</li></ul><p>浏览器中不同类型变量的内存都是何时释放？</p><ul><li>思路：分为值类型、引用类型</li></ul><p><a href="https://www.cnblogs.com/crazycode2/p/14747974.html">哪些情况会导致内存泄漏？如何避免？</a></p><ul><li>思路：内存泄漏是指你用不到（访问不到）的变量，依然占据着内存空间，不能被再次利用起来。</li></ul><p>weakMap、weakSet、Set、Map 有什么区别？</p><ul><li>思路：WeakMap、WeakSet 弱引用，解决了内存泄漏问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object.defineProperty和Proxy区别</title>
      <link href="/posts/52f35dcbc3ed/"/>
      <url>/posts/52f35dcbc3ed/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="代理和反射">代理和反射</h2><p>vue2 中的 Object.defineProperty()和 vue3 中的 Proxy()本质上的作用都是代理。<br>那么什么是代理和反射呢？</p><ul><li>反射和代理就是<strong>一种拦截并向基本操作嵌入额外行为的能力。<strong>本质上属于数据劫持</strong>。</strong></li><li>反射<strong>Reflect</strong> 是一个内建对象**，**可简化 Proxy 的创建。</li><li>Reflect 对象使调用一些内部方法（[[Get]]、[[Set]]等）成为可能，它的方法是内部方法的最小包装。<ul><li>Reflect 允许我们将操作符（new，delete 等）作为函数（<code>Reflect.construct</code>，<code>Reflect.deleteProperty</code>等）执行调用。</li><li>对于每个可被<code>Proxy</code>捕获的内部方法，在<code>Reflect</code>中都有一个对应的方法，其名称和参数与 Proxy 捕捉器相同。所以，我们可以使用 Reflect 来将操作转发给原始对象。</li><li>Reflect 调用的命名与捕捉器的命名完全相同，并且接收相同的参数，因此，return Reflect … 提供了一个安全的方式，可以轻松地转发操作，并确保我们不会忘记与此相关的任何内容。</li></ul></li><li>代理是目标对象抽象，也就是说，它可以用做目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。</li></ul><p>来个简单的例子理解代理操作：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  id: <span class="string">&quot;target&quot;</span>,</span><br><span class="line">&#125;; <span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;; <span class="comment">// 代理对象</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// target</span></span><br></pre></td></tr></table></figure><blockquote><p>显然，通过 Proxy 代理把目标对象上的属性映射到了代理对象身上。</p></blockquote><h2 id="Object-defineProperty-与-Proxy-的区别">Object.defineProperty() 与 Proxy 的区别</h2><h3 id="Object-defineProperty">Object.defineProperty()</h3><p>defineProperty() 捕获器会在 Object.defineProperty()中被调用。<br>Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改也跟对象的现有属性，并返回此对象。<br><strong>defineProxy()捕获器处理程序参数</strong>：</p><ol><li>obj：要在其上定义属性的对象</li><li>prop：要定义或修改的属性的名称或 Symbol</li><li>descriptor：定义或修改的属性描述符</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor);</span><br></pre></td></tr></table></figure><p>缺点：只能劫持对象的属性，无法监听新增属性和数组的变化（Vue）。</p><blockquote><p>对象中目前存在的属性描述符有两种主要形式：数据（属性）描述符和存取描述符（访问器属性）。数据描述符是一个具有值的属性，该值是可写的，也可以是不可写的。存取描述符是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一，<strong>不能同时是两者。</strong><br>属性描述符：</p><ul><li>value：值</li><li>writable：如果为 true，则会被在循环中列出，否则不会被列出</li><li>emumerable：如果为 true，则会被在循环在列出，否则不会被列出。</li><li>configurable：如果为 true，则此属性可以被删除，这些特性也可以被修改，否则不可以。</li></ul><p><strong>访问器属性：</strong></p><ul><li>get：一个没有参数的函数，在读取属性时工作</li><li>set：带有一个参数的函数，当属性被设置时调用</li><li>enumerate：与数据属性的相同</li><li>configurable：与数据属性的相同</li></ul></blockquote><h3 id="Proxy">Proxy</h3><blockquote><p>Proxy 主要用于改变对象的默认访问行为，实际上是在访问对象前增加一层拦截，在任何对对象的访问行为都会通过这层拦截。</p></blockquote><p>Proxy 的参数为：</p><ol><li>target：目标对象</li><li>handler：配置对象，用来定义拦截的行为</li><li>proxy：Proxy 构造器的实例</li></ol><p>体现的功能有：</p><ol><li>拦截功能</li><li>提供对象访问</li><li><strong>可以重写属性或构造函数</strong></li></ol><h4 id="好处">好处</h4><ol><li>能够代理任何对象包括数组和函数、对象</li><li>比 Object.defineProperty()更多的语义的操作（get、set、delete）</li><li>不用循环遍历对象，然后再使用 Object.defineProperty，Proxy 可以代理对象内的所有属性</li><li>Object.defineProperty() 只能劫持对象的属性（给对象新添加属性 vue 无法检测到）</li></ol><h4 id="局限性">局限性</h4><ol><li>无法代理内部对象的内部插槽<ol><li>许多内建对象，例如 Map、Set、Date、Promise 等，都使用了所谓的“内部插槽“。</li></ol></li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(map, &#123;&#125;);</span><br><span class="line">proxy.set(<span class="string">&quot;test&quot;</span>, <span class="number">1</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>解决方法：在 get 时将 get 要返回的值先绑定目标对象后返回。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(map, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value == <span class="string">&quot;function&quot;</span> ? value.bind(target) : value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.set(<span class="string">&quot;test&quot;</span>, <span class="number">1</span>);</span><br><span class="line">alert(proxy.get(<span class="string">&quot;test&quot;</span>)); <span class="comment">// 1（工作了！）</span></span><br></pre></td></tr></table></figure><ol start="2"><li>无法代理私有字段（同上）</li><li>proxy != target 代理对象和目标对象是不===的。</li></ol><h4 id="总结">总结</h4><ul><li>Proxy 是对象的包装器，将代理上的操作转发给对象，并可以选择捕获其中一些操作。</li><li>可以包含任何类型的对象，包括类和函数。</li><li>Reflect 旨在补充 Proxy，对于任意 Proxy 捕捉器，都有一个带有相同参数的 Reflect 调用，我们应该使用它们将调用转发给目标对象。</li></ul><h3 id="区别">区别</h3><ol><li>Proxy 是对整个对象的代理，而 Object.defineProperty()只能代理某个属性</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Proxy</span></span><br><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">    d: &#123; <span class="attr">e</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="comment">//捕获器</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">trapTarget, prop, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;触发get:&quot;</span>, prop);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(trapTarget, prop); <span class="comment">// 反射API // 只要在代理上调用，所有捕获器都会拦截它们对应的反射API操作</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">trapTarget, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;触发set:&quot;</span>, key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line">proxy.b.c; <span class="comment">// 触发get: b</span></span><br><span class="line">proxy.b.d.e; <span class="comment">// 触发get: b //说明都不能够遍历到深层次的地方，只能代理最外层属性</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy); <span class="comment">//&#123; a: 1, b: &#123; c: 2, d: &#123; e: 3 &#125; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.defineProperty</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  value: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// &#x27;张三&#x27;</span></span><br><span class="line">obj.name = <span class="string">&quot;李四&quot;</span>; <span class="comment">// 给obj.name赋新值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 张三  //默认writable为false，即不可改</span></span><br></pre></td></tr></table></figure><ol start="2"><li>对象上新增属性和数组新增修改，Proxy 可以监听到，Object.defineProperty()不能（Vue2 中）</li><li>若对象内部属性要全部递归代理，Proxy 可以只在调用时递归，而 Object.defineProperty()需要一次性完成所有递归，性能比 Proxy 差。</li></ol><p>假如对象嵌套层级比较深的话，每一次都需要循环遍历（采用递归代理）。</p><ol start="4"><li>Proxy 只在现代浏览器采用，不兼容 IE，Object.defineProperty()不兼容 IE8 及以下</li><li>如果 Object.defineProperty 遍历到对象不存在的属性时，它是检测不到变化的。</li></ol><h2 id="Vue2-和-Vue3-代理基础架构对比">Vue2 和 Vue3 代理基础架构对比</h2><h3 id="Vue2-中的-defineProperty-基础架构">Vue2 中的 defineProperty 基础架构</h3><p>假如我们定义考了一个 defineProperty()函数来实现代理映射的效果，里面包含了 get 和 set 方法，如果触发了 get 方法，那么直接映射源数据 value；<br>如果触发了 set 方法，那么先判断新的数据是否等于原来的数据，这样做是为了避免无效更新视图层，减少性能损耗。<br>如果不等于源数据，那么就将 newValue 更新赋值给 value。<br>然后再更新视图层，这样就实现了最基本的响应式数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dinner = &#123;</span><br><span class="line">  meal: <span class="string">&quot;tacos&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue !== value) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="comment">//更新视图层</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> dinner) &#123;</span><br><span class="line">  defineReactive(dinner, key, dinner[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;set之前&quot;</span>, dinner.meal); <span class="comment">//set之前 tacos</span></span><br><span class="line"></span><br><span class="line">dinner.meal = <span class="string">&quot;changed&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;set之后&quot;</span>, dinner.meal); <span class="comment">//set之后 changed</span></span><br></pre></td></tr></table></figure><h3 id="Vue3-中的-Proxy-基础架构">Vue3 中的 Proxy 基础架构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dinner = &#123;</span><br><span class="line">  meal: <span class="string">&quot;tacos&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">//这里的key指的是访问的property</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value</span>)</span> &#123;</span><br><span class="line">    target[key] = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(dinner, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;set之前&quot;</span>, proxy.meal); <span class="comment">//set之前 tacos</span></span><br><span class="line"></span><br><span class="line">proxy.meal = <span class="string">&quot;changed&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;set之后&quot;</span>, proxy.meal); <span class="comment">//set之后 changed</span></span><br></pre></td></tr></table></figure><p>可以看到都能实现响应式数据变化。<br>但是，我们考虑到如果是多层嵌套或者数组时，更改一下 defineProperty 中的例子：<br>把原对象变为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dinner = &#123;</span><br><span class="line">  meal: <span class="string">&quot;tacos&quot;</span>,</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    c: &#123;</span><br><span class="line">      d: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      e: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么在层级比较深并且包含数组的情况下，该如何实现响应式呢？<br>此时，我们需要一个 observer 来观测 value 的类型，再决定遍历的方式和次数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&quot;object&quot;</span> || target == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target)) &#123;</span><br><span class="line">    <span class="comment">//拦截数组，给数组的方法进行了重写</span></span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(target, proto);</span><br><span class="line">    <span class="comment">//target.__proto__ = proto</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; target.length; i++) &#123;&#125;</span><br><span class="line">    observer(target[i]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//是对象的话，就进行层层递归</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      defineReactive(target, key, target[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归遍历，继续拦截对象</span></span><br><span class="line">  observer(value);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">    (target,</span><br><span class="line">    key,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue !== value) &#123;</span><br><span class="line">          observer(newValue);</span><br><span class="line">          <span class="comment">// updateView 更新视图的方法</span></span><br><span class="line">          value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里可以看出 defineProperty 的缺点，在重写的 defineReactive 方法里，显然性能损耗基本上是在 observer 上。<br>而在 Vue3 中的 Proxy 可以很好的解决上面的问题。</p></blockquote><h2 id="总结-v2">总结</h2><p>相同点：二者都可以对属性进行代理。<br>不同点：</p><ol><li>代理的粒度不同：defineProperty 只能代理对象的属性，Proxy 代理的是对象。</li></ol><ul><li>如果想代理对象的所有属性，defineProperty 需要遍历属性一个个加 setter 和 getter。</li><li>而 Proxy 只需要配置一个可以获取属性名参数的函数即可。</li><li>如果出现嵌套的函数，Proxy 也是要递归进行代理的，但可以做惰性代理（按需代理），即用到嵌套对象时再创建对应的 Proxy。</li></ul><ol start="2"><li>是否破坏原对象。</li></ol><p><strong>defineProperty 的代理行为是在破坏原对象的基础上实现的</strong>，它通常会将原来的 value 变成了 setter 和 getter。<br><strong>Proxy 则不会破坏原对象</strong>，只是在原对象上覆盖了一层。当新增属性时，希望属性被代理，defineProperty 需要显式调用该 API，而 Proxy 则可以直接用<code>obj.key = val</code>的形式。<br>Proxy 返回的是一个新的对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改。</p><ol start="3"><li>代理数组属性</li></ol><p>defineProperty 只能代理常规对象，不适合监听数组属性，因为数组长度可能很大，比如几百万，一个个对索引使用 defineProperty 是无法接受的。</p><ul><li>一种方法是重写数组的 API 方法（比如 splice），通过它们来实现代理，但它是有缺陷的：直接用 arr[1] = 100 无法触发代理。（Vue2 做法）</li><li>另外，我们无法对数组的 length 做代理。这暴露了 defineProperty 的一个缺陷：**设置了 configurable 为 false 的属性无法进行代理。**数组的 length 就是这种情况。</li></ul><p>Proxy 则没有这个问题，它只需要设置一个 setter 和 getter，在属性变化时，能够在函数参数上拿到索引值。<strong>它可以代理任何对象（函数、数组、类），不能代理内部对象的内部插槽。</strong></p><ol start="4"><li>代理范围：defineProperty 只能代理属性的 get 和 set。</li></ol><p>Proxy 还能代理其他的行为，比如 delete 和 handler.getPropertypeOf()等方法。</p><ol start="5"><li>兼容性：Proxy 是 ES6 新增的特性，兼容性不如 defineProperty。</li></ol><p>IE 不支持 Proxy。<br>且 Proxy 不能被<a href="https://blog.csdn.net/sujinchang939024/article/details/118498394">polyfill</a>磨平，因为它是在编程语言层面上的修改。<br>Proxy 还有一些性能问题，但作为标准，浏览器会持续做重点性能优化。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 响应式原理和双向绑定原理区分</title>
      <link href="/posts/a4e92ec6fdfc/"/>
      <url>/posts/a4e92ec6fdfc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>数据响应式原理</h1><p>通过<strong>数据劫持结合发布-订阅者模式</strong>的方式来实现的。<br>Vue 内部通过 Object.defineProperty() 监听对象属性的改变，它有对应的两个描述属性 get 和 set，当数据发生改变后，通过此方法对两个属性进行重写操作，从而通过发布-订阅者模式通知界面发生改变。<br>Vue2 是借助 Object.defineProperty() 实现的，而 Vue3 是借助 Proxy 实现的，通过 Proxy 对象创建一个对象的代理，并且 Proxy 的监听是深层次的，监听整个对象，而不是某个属性。<br><strong>发布-订阅者模式：</strong><br><img src="https://raw.githubusercontent.com/coder-fang/myBlogImgRespository/master/img/20221208120909.png" alt=""></p><ol><li>new Vue() 首先执行初始化，对 data 执行响应化处理，此过程发生在 Observer 中</li><li>compiler 对模板执行编译，找到其中动态绑定的数据，从 data 中获取并初始化视图</li><li>由于 data 的某个 key 在一个视图中可能出现多次，所以每个 key 都需要一个管家 Dep 来管理多个 Watcher</li><li>同时定义一个更新函数 update()和 Watcher，将来对应数据变化时 Watcher 会调用更新函数。</li><li>一旦 data 中数据发生变化，会首先找到对应的 Dep，通知所有的 Watcher 执行更新函数，然后更新视图。</li></ol><h3 id="Vue2-的实现：">Vue2 的实现：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">//拦截get，当我们访问data.key时会被这个方法拦截到</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> <span class="title">getter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//我们在这里收集依赖</span></span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//拦截set，当我们为data.key赋值时会被这个方法拦截到</span></span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> <span class="title">setter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当数据变更时，通知依赖项变更UI</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>通过 Object.defineProperty() 为对象 obj 添加属性，可以设置对象属性的 getter 和 setter 函数。</li><li>之后我们每次通过点语法获取属性都会执行这里的 getter 函数，此函数中我们把调用此属性的依赖收集到一个集合中；</li><li>而在我们给属性赋值时（修改属性），会触发这里定义的 setter 函数，在此函数中会去通知集合中的依赖更新，做到数据驱动视图更新。</li></ul><h3 id="Vue3-的实现：">Vue3 的实现：</h3><p>Vue3 与 Vue2 的核心思想一致，不过数据的劫持使用的是 Proxy 而不是 Object.defineProperty() ，只不过 Proxy 相比 Object.defineProperty() 在处理数组和新增属性的响应式处理上更加方便。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">//拦截get，当我们访问nObj.key时会被这个方法拦截到</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//拦截set，当我们为nObj.key赋值时会被这个方法拦截到</span></span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, propKey, value, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1>数据双向绑定原理</h1><p>可以通过 v-model 和修饰符.sync 两种方式实现，像在组件中使用 v-model 就属于双向绑定。<br>v-model 本质是：</p><ol><li>将动态的 data 通过 value 属性传递给 input 显示</li><li>给 input 标签绑定 input 监听，一旦输入改变，读取最新的值保存到 data 对应属性上</li></ol><p>双向绑定由三个重要部分构成：</p><ul><li>数据层（Model）：页面渲染所需要的数据</li><li>视图层（View）：所呈现出的页面</li><li>业务逻辑层（ViewModel）：框架封装的核心；重要职责：数据变化后更新视图，视图变化后更新数据。</li></ul><h3 id="使用-Object-defineProperty-实现双向绑定">使用 Object.defineProperty()实现双向绑定</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    hello,world</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;model&quot;</span> oninput=<span class="string">&quot;handleChange()&quot;</span> /&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;word&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// TODO  双向数据绑定：页面中输入框中用户输入变化时其它控件中内容也跟着变化</span></span><br><span class="line">    <span class="keyword">let</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&quot;model&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&quot;word&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> data = &#123;&#125;;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, <span class="string">&quot;val&quot;</span>, &#123;</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            val = newVal;</span><br><span class="line">            input.value = val;</span><br><span class="line">            p.innerHTML = val;</span><br><span class="line">        &#125;,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        data.val = input.value; <span class="comment">// 触发set</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>效果：在输入内框内输入内容，下方数据会相应改变。<br><img src="https://raw.githubusercontent.com/coder-fang/myBlogImgRespository/master/img/20221208124835.png" alt=""></p><h3 id="使用-Proxy-实现响应式">使用 Proxy 实现响应式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        naisu: <span class="number">233</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> handler = &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property, receiver</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target[property];</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">target, property, value, receiver</span>) </span>&#123;</span><br><span class="line">            target[property] = value;</span><br><span class="line">            btn.innerText = <span class="string">`Naisu is <span class="subst">$&#123;target[property]&#125;</span>.`</span>; <span class="comment">// 值在改变的同时更新视图</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 注意target属性操作使用[]</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line"></span><br><span class="line">    btn.onclick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        objProxy.naisu = objProxy.naisu + <span class="number">1</span>; <span class="comment">// 在真正操作时只要关系数据就行</span></span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/coder-fang/myBlogImgRespository/master/img/20221208125406.png" alt=""><br>好处：数据驱动视图，之后操作关心数据本身即可，无需因为数据改变去手动操作视图了。</p><h3 id="Proxy-实现数据双向绑定">Proxy 实现数据双向绑定</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    hello,world</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;model&quot;</span> oninput=<span class="string">&quot;inputHandler()&quot;</span> /&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;word&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// TODO  ES6实现</span></span><br><span class="line">    <span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&quot;model&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&quot;word&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        naisu: <span class="number">233</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> handler = &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property, receiver</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target[property];</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">target, property, value, receiver</span>) </span>&#123;</span><br><span class="line">            target[property] = value;</span><br><span class="line">            p.innerHTML = <span class="string">`Naisu is <span class="subst">$&#123;target[property]&#125;</span>`</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inputHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        objProxy.naisu = input.value; <span class="comment">// 输入事件中改变代理对象属性值</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/coder-fang/myBlogImgRespository/master/img/20221208125431.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 响应式 </tag>
            
            <tag> 双向绑定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shadow dom</title>
      <link href="/posts/ccf4917e1e49/"/>
      <url>/posts/ccf4917e1e49/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="问题引入：">问题引入：</h2><p>input 为什么能输入内容？</p><h2 id="思路：">思路：</h2><ol><li>以 Chrome 为例，F12 打开 Chrome 浏览器控制台，点击设置，开启 Element 下的 Show user agent shadow DOM 选项，可以看见一些隐藏的结构：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/coder-fang/myBlogImgRespository/img/20221208130211.png" alt=""></p><blockquote><p>可以看到 input 标签下有一个 shadow-dom，点开 shadow-dom 可以看到里面的内容。这其中的内容就是具体的实现。</p></blockquote><h2 id="Shadow-DOM">Shadow DOM</h2><h3 id="什么是-Shadow-DOM？">什么是 Shadow DOM？</h3><p>Shadow DOM 是”DOM 中的 DOM“，是独立的 DOM，具有自己的元素和样式，与原始 DOM 完全隔离，是我们无法控制操作的 DOM。<br>相当于一个作用域的概念，使其不被外部所影响。可以看做是一颗单独的 DOM 树，这样就不会有 css 的命名冲突或样式的意外泄漏的情况。</p><h3 id="为什么需要-Shadow-DOM？">为什么需要 Shadow DOM？</h3><ul><li>shadow dom 是游离于 DOM 树之外的节点树，但其创建是基于普通的 DOM 元素（非 document），并且创建的节点可以直接从界面上直观的看到</li><li>shadow dom 有良好的密封性（浏览器提供的一种“封装”功能，提供了一种强大的技术去隐藏一些实现细节。）</li></ul><h3 id="如何创建-Shadow-DOM？">如何创建 Shadow DOM？</h3><ul><li>首先，我们指定一个<strong>宿主节点（shadow host）</strong>，然后创建影子根（<strong>shadow root</strong>），为它添加一个文本节点，但结果宿主中的内容未被渲染。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;widget&quot;</span>&gt;Hello, world!&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> host = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.widget&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> root = host.attachShadow(&#123;</span><br><span class="line">        mode: <span class="string">&quot;open&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    root.textContent = <span class="string">&quot;我在你的 div 里！&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://raw.githubusercontent.com/coder-fang/myBlogImgRespository/master/img/649e.png" alt=""><br>那么如何渲染宿主节点中的内容？<br>可以使用<code>slot</code>标签。由于目前<code>content</code>标签已经弃用，可以使用<code>slot</code>标签代替。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pokemon&quot;</span>&gt;大酱&lt;/div&gt;</span><br><span class="line">&lt;template <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pokemon-template&quot;</span>&gt;</span><br><span class="line">  &lt;h1&gt;你好，我是&lt;slot&gt;&lt;<span class="regexp">/slot&gt;，请多指教！&lt;/</span>h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> host = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.pokemon&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> root = host.attachShadow(&#123;</span><br><span class="line">        mode: <span class="string">&quot;open&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> template = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.pokemon-template&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(template.content);</span><br><span class="line">    root.appendChild(<span class="built_in">document</span>.importNode(template.content, <span class="literal">true</span>));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>显示结果：<br><img src="https://cdn.jsdelivr.net/gh/coder-fang/myBlogImgRespository/img/20221208130237.png" alt=""><br><code>&lt;slot&gt;</code>标签创建了一个<strong>插入点</strong>将<code>.pokemon</code>里面的文本投影出来，多个内容匹配时可以使用<code>name</code>属性指定。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;host&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;啦啦啦啦&lt;/p&gt;</span><br><span class="line">    &lt;span slot=<span class="string">&quot;name&quot;</span>&gt;大酱呀&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;root-template&quot;</span>&gt;</span><br><span class="line">  &lt;dl&gt;</span><br><span class="line">    &lt;h1&gt;<span class="xml"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span>&lt;/h1&gt;</span><br><span class="line">    &lt;dd&gt;<span class="xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span>&lt;/dd&gt;</span><br><span class="line">    &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span>&lt;/p&gt;</span><br><span class="line">  &lt;/dl&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> host = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.host&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> root = host.attachShadow(&#123;</span><br><span class="line">        mode: <span class="string">&quot;open&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> template = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.root-template&quot;</span>);</span><br><span class="line">    root.appendChild(<span class="built_in">document</span>.importNode(template.content, <span class="literal">true</span>));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>显示结果：<br><img src="https://cdn.jsdelivr.net/gh/coder-fang/myBlogImgRespository/img/20221208130255.png" alt=""></p><blockquote><p>注意：</p><ol><li>只有封闭区域，才能作为 shadow Host</li><li>当我们把一个标签设置成 shadow dom 时，里面的子元素将全部失效。</li><li>当 mode 为 closed 时，禁止你使用的 shadow Root 属性从 root 外部访问 shadow root 元素</li></ol></blockquote><blockquote><p>如何修改 shadow dom 的样式？</p><ol><li>在 shadow 块下面创建 style 标签，在里面添加样式。</li><li>mode 为 true 时，通过 shadow root 获取到指定元素修改样式。</li></ol></blockquote><h3 id="样式渲染">样式渲染</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    button &#123;</span><br><span class="line">        font-size: 18px;</span><br><span class="line">        font-family: <span class="string">&quot;华文行楷&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;button&gt;普通按钮&lt;/button&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> host = <span class="built_in">document</span>.querySelector(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> root = host.attachShadow(&#123;</span><br><span class="line">        mode: <span class="string">&quot;open&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    root.innerHTML =</span><br><span class="line">        <span class="string">&quot;&lt;style&gt;button &#123; font-size: 24px; color: blue; &#125; &lt;/style&gt;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&lt;button&gt;影子按钮&lt;/button&gt;&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>显示结果：<br><img src="https://cdn.jsdelivr.net/gh/coder-fang/myBlogImgRespository/img/20221208130315.png" alt=""><br>在影子节点中存在边界使 shadow dom 样式和正常 DOM 流中的样式互不干扰，这是一种作用域化的体现，不用担心样式的相互冲突。</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keep-alive实现原理</title>
      <link href="/posts/60155ccd2fe9/"/>
      <url>/posts/60155ccd2fe9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><ul><li>该组件内没有常规的<code>&lt;template&gt;&lt;/template&gt;</code>等标签，因为它不是一个常规的模板组件，取而代之的是，它内部多了一个 render 函数，它是一个函数式组件。执行<code>&lt;keep-alive&gt;</code>组件渲染时，就会执行这个<code>render</code>函数。</li><li>keep-alive 缓存机制是根据 LRU 策略来设置缓存组件新鲜度，将很久未访问的组件从缓存中删除。</li></ul><h2 id="组件实现原理">组件实现原理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码位置：src/core/components/keep-alive.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line">  abstract: <span class="literal">true</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes,</span><br><span class="line">    exclude: patternTypes,</span><br><span class="line">    max: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">this</span>.keys = [];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.cache) &#123;</span><br><span class="line">      pruneCacheEntry(<span class="built_in">this</span>.cache, key, <span class="built_in">this</span>.keys);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$watch(<span class="string">&quot;include&quot;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      pruneCache(<span class="built_in">this</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> matches(val, name));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.$watch(<span class="string">&quot;exclude&quot;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      pruneCache(<span class="built_in">this</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> !matches(val, name));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> slot = <span class="built_in">this</span>.$slots.default;</span><br><span class="line">    <span class="keyword">const</span> vnode: VNode = getFirstComponentChild(slot);</span><br><span class="line">    <span class="keyword">const</span> componentOptions: ?VNodeComponentOptions =</span><br><span class="line">      vnode &amp;&amp; vnode.componentOptions;</span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">      <span class="comment">// check pattern</span></span><br><span class="line">      <span class="keyword">const</span> name: ?string = getComponentName(componentOptions);</span><br><span class="line">      <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// not included</span></span><br><span class="line">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">        <span class="comment">// excluded</span></span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">const</span> key: ?string =</span><br><span class="line">        vnode.key == <span class="literal">null</span></span><br><span class="line">          ? <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">            <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">            componentOptions.Ctor.cid +</span><br><span class="line">            (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&quot;&quot;</span>)</span><br><span class="line">          : vnode.key;</span><br><span class="line">      <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance;</span><br><span class="line">        <span class="comment">// make current key freshest</span></span><br><span class="line">        remove(keys, key);</span><br><span class="line">        keys.push(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache[key] = vnode;</span><br><span class="line">        keys.push(key);</span><br><span class="line">        <span class="comment">// prune oldest entry</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="built_in">this</span>.max)) &#123;</span><br><span class="line">          pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="built_in">this</span>._vnode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>]);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>keep-alive 实际上是一个抽象组件，只对包裹的组件做处理 ，并不会和子组件建立父子关系，也不会作为节点渲染到页面上。在组件开头就设置 abstract 为 true，代表该组件是一个抽象组件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码位置：src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.$options;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// locate first non-abstract parent</span></span><br><span class="line">  <span class="keyword">let</span> parent = options.parent;</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent = parent.$parent;</span><br><span class="line">    &#125;</span><br><span class="line">    parent.$children.push(vm);</span><br><span class="line">  &#125;</span><br><span class="line">  vm.$parent = parent;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么抽象组件是如何忽略这层关系的？在初始化阶段会调用 initLifecycle，里面判断父级是否为抽象组件，如果是抽象组件，就选取抽象组件中的上一级作为父级，忽略与抽象组件和子组件之间的层级关系。<br>keep-alive 组件没有编写 template 模板，而是由 render 函数决定是否渲染结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> slot = <span class="built_in">this</span>.$slots.default;</span><br><span class="line"><span class="keyword">const</span> vnode: VNode = getFirstComponentChild(slot);</span><br></pre></td></tr></table></figure><p>如果 keep-alive 存在多个子元素，keep-alive 要求同时只有一个子元素被渲染。所以在开头会获取插槽内的子元素，调用 getFirstComponentChild 获取到第一个子元素的 VNode。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check pattern</span></span><br><span class="line"><span class="keyword">const</span> name: ?string = getComponentName(componentOptions);</span><br><span class="line"><span class="keyword">const</span> &#123; include, exclude &#125; = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  <span class="comment">// not included</span></span><br><span class="line">  (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">  <span class="comment">// excluded</span></span><br><span class="line">  (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matches</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  pattern: string | <span class="built_in">RegExp</span> | <span class="built_in">Array</span>&lt;string&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(pattern)) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.indexOf(name) &gt; -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> pattern === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.split(<span class="string">&quot;,&quot;</span>).indexOf(name) &gt; -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRegExp(pattern)) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.test(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着判断的当前组件是否符合缓存条件，组件名与 include 不匹配或与 exclude 匹配都会直接退出并返回 vnode，不走缓存机制。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; cache, keys &#125; = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">const</span> key: ?string =</span><br><span class="line">  vnode.key == <span class="literal">null</span></span><br><span class="line">    ? <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">      <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">      componentOptions.Ctor.cid +</span><br><span class="line">      (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&quot;&quot;</span>)</span><br><span class="line">    : vnode.key;</span><br><span class="line"><span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">  vnode.componentInstance = cache[key].componentInstance;</span><br><span class="line">  <span class="comment">// make current key freshest</span></span><br><span class="line">  remove(keys, key);</span><br><span class="line">  keys.push(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  cache[key] = vnode;</span><br><span class="line">  keys.push(key);</span><br><span class="line">  <span class="comment">// prune oldest entry</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="built_in">this</span>.max)) &#123;</span><br><span class="line">    pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="built_in">this</span>._vnode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">vnode.data.keepAlive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>匹配条件通过会进入缓存机制的逻辑，如果命中缓存机制，从 cache 中获取缓存的实例设置到当前的组件上，并调整 key 的位置将其放到最后，如果没有命中缓存，将当前 vnode 缓存起来，并加入到当前组件的 key。如果缓存组件的数量不足，即缓存空间不足，则调用 pruneCacheEntry 将最旧的组件从缓存中删除，即 keys[0]的组件。之后将组件的 keepAlive 标记为 true，表示它是被缓存的组件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCacheEntry</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  cache: VNodeCache,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  keys: <span class="built_in">Array</span>&lt;string&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  current?: VNode</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cached = cache[key];</span><br><span class="line">  <span class="keyword">if</span> (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123;</span><br><span class="line">    cached.componentInstance.$destroy();</span><br><span class="line">  &#125;</span><br><span class="line">  cache[key] = <span class="literal">null</span>;</span><br><span class="line">  remove(keys, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pruneCacheEntry 负责将组件从缓存中删除，它会调用组件<code>$destory</code>方法销毁组件实例，缓存组件置空，并移除对应的 key。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">  <span class="built_in">this</span>.$watch(<span class="string">&#x27;include&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    pruneCache(<span class="built_in">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> matches(val, name))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">this</span>.$watch(<span class="string">&#x27;exclude&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    pruneCache(<span class="built_in">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> !matches(val, name))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCache</span> (<span class="params">keepAliveInstance: any, filter: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; cache, keys, _vnode &#125; = keepAliveInstance</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">    <span class="keyword">const</span> cachedNode: ?VNode = cache[key]</span><br><span class="line">    <span class="keyword">if</span> (cachedNode) &#123;</span><br><span class="line">      <span class="keyword">const</span> name: ?string = getComponentName(cachedNode.componentOptions)</span><br><span class="line">      <span class="keyword">if</span> (name &amp;&amp; !filter(name)) &#123;</span><br><span class="line">        pruneCacheEntry(cache, key, keys, _vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>keep-alive 在 mounted 会监听 include 和 exclude 的变化，属性发生改变时，调整缓存和 keys 的顺序，最终调用的也是 pruneCacheEntry。</p><h3 id="小结">小结</h3><p>cache 用于缓存组件，keys 存储组件的 key，根据 LRU 策略来调整缓存组件。keep-alive 的 render 中最后会返回组件的 vnode，因此：keep-alive 并非真的不会渲染，而是渲染的对象是包裹的子组件。</p><h2 id="组件渲染流程">组件渲染流程</h2><h2 id="props">props</h2><p>在选项内接收传进来的三个属性：include、exclude、max。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    include: [<span class="built_in">String</span>, <span class="built_in">RegExp</span>, <span class="built_in">Array</span>],</span><br><span class="line">    exclude: [<span class="built_in">String</span>, <span class="built_in">RegExp</span>, <span class="built_in">Array</span>],</span><br><span class="line">    max: [<span class="built_in">String</span>, <span class="built_in">Number</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>include</code>表示只有匹配的组件会被缓存</li><li><code>exclude</code>表示任何匹配到的组件都不会被缓存</li><li><code>max</code>表示缓存组件的数量，因为我们缓存的<code>vnode</code>对象，它也会持有 DOM，当我们缓存的组件很多时，会比较占内存，所以该配置允许我们指定缓存组件的数量。</li></ul><h2 id="created">created</h2><p>在<code>created</code>钩子函数中，定义并初始化了两个属性：<code>this.cache</code>、<code>this.keys</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">    <span class="built_in">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>.keys = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>this.cache 是一个对象，用来存储需要缓存的组件，它以如下形式存储：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.cache = &#123;</span><br><span class="line">  key1: <span class="string">&quot;组件1&quot;</span>,</span><br><span class="line">  key2: <span class="string">&quot;组件2&quot;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>this.keys</code>是一个数组，用来存储每个需要缓存的组件的 key，即对应的 this.cache 对象中的键值。</li></ul><h2 id="destroyed">destroyed</h2><p>当<code>&lt;keep-alive&gt;</code>组件被销毁时，此时会调用<code>destroyed</code>钩子函数，在该钩子函数里会遍历<code>this.cache</code>对象，然后将那些被缓存并当前没有处于被渲染状态是组件都销毁掉。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">destroyed () &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.cache) &#123;</span><br><span class="line">        pruneCacheEntry(<span class="built_in">this</span>.cache, key, <span class="built_in">this</span>.keys)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pruneCacheEntry函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCacheEntry</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  cache: VNodeCache,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  keys: <span class="built_in">Array</span>&lt;string&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  current?: VNode</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cached = cache[key]</span><br><span class="line">  <span class="comment">/* 判断当前没有处于被渲染状态的组件，将其销毁*/</span></span><br><span class="line">  <span class="keyword">if</span> (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123;</span><br><span class="line">    cached.componentInstance.$destroy()</span><br><span class="line">  &#125;</span><br><span class="line">  cache[key] = <span class="literal">null</span></span><br><span class="line">  remove(keys, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mounted">mounted</h2><p>在 mounted 钩子函数中观测<code>include</code>和<code>exclude</code>的变化，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">    <span class="built_in">this</span>.$watch(<span class="string">&#x27;include&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        pruneCache(<span class="built_in">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.$watch(<span class="string">&#x27;exclude&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        pruneCache(<span class="built_in">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> !matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 include 和 exclude 发生了变化，即表示定义需要缓存的组件的规则或不需要缓存的组件的规则发生了变化，则执行 pruneCache 函数，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCache</span>(<span class="params">keepAliveInstance, filter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; cache, keys, _vnode &#125; = keepAliveInstance;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">    <span class="keyword">const</span> cachedNode = cache[key];</span><br><span class="line">    <span class="keyword">if</span> (cachedNode) &#123;</span><br><span class="line">      <span class="keyword">const</span> name = getComponentName(cachedNode.componentOptions);</span><br><span class="line">      <span class="keyword">if</span> (name &amp;&amp; !filter(name)) &#123;</span><br><span class="line">        pruneCacheEntry(cache, key, keys, _vnode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数内对 this.cache 对象进行遍历，取出每一项的 name 值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用 <code>pruneCacheEntry</code>将其从<code>this.cache</code>对象剔除即可。</p><h2 id="render">render</h2><p>在 render 函数中首先获取第一个子组件节点的 vnode：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取默认插槽中的第一个组件节点 */</span></span><br><span class="line"><span class="keyword">const</span> slot = <span class="built_in">this</span>.$slots.default;</span><br><span class="line"><span class="keyword">const</span> vnode = getFirstComponentChild(slot);</span><br></pre></td></tr></table></figure><p>由于我们也是在<code>&lt;keep-alive&gt;</code>标签内部写 DOM，所以可以先获取到默认插槽，然后再获取到它的第一个子节点。<br><code>&lt;keep-alive&gt;</code>只处理第一个子元素，所以一般和它搭配使用的有 <code>component</code>动态组件或者是 <code>router-view</code>。<br>接下来，获取该组件节点的名称：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取该组件节点的名称 */</span></span><br><span class="line"><span class="keyword">const</span> name = getComponentName(componentOptions);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优先获取组件的name字段，如果name不存在则获取组件的tag */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponentName</span>(<span class="params">opts: ?VNodeComponentOptions</span>): ?<span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> opts &amp;&amp; (opts.Ctor.options.name || opts.tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用组件名称跟 include、exclude 中的匹配规则去匹配。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; include, exclude &#125; = <span class="built_in">this</span>;</span><br><span class="line"><span class="comment">/* 如果name与include规则不匹配或者与exclude规则匹配则表示不缓存，直接返回vnode */</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">  <span class="comment">// excluded</span></span><br><span class="line">  (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果组件名称与 include 规则不匹配或者与 exclude 规则匹配，则表示不缓存该组件，直接返回这个组件的 vnode，否则，走下一步缓存。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; cache, keys &#125; = <span class="built_in">this</span>;</span><br><span class="line"><span class="comment">/* 获取组件的key */</span></span><br><span class="line"><span class="keyword">const</span> key =</span><br><span class="line">  vnode.key == <span class="literal">null</span></span><br><span class="line">    ? componentOptions.Ctor.cid +</span><br><span class="line">      (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&quot;&quot;</span>)</span><br><span class="line">    : vnode.key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */</span></span><br><span class="line"><span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">  vnode.componentInstance = cache[key].componentInstance;</span><br><span class="line">  <span class="comment">/* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */</span></span><br><span class="line">  remove(keys, key);</span><br><span class="line">  keys.push(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* 如果没有命中缓存，则将其设置进缓存 */</span></span><br><span class="line">  cache[key] = vnode;</span><br><span class="line">  keys.push(key);</span><br><span class="line">  <span class="comment">/* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="built_in">this</span>.max)) &#123;</span><br><span class="line">    pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="built_in">this</span>._vnode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 最后设置keepAlive标记位 */</span></span><br><span class="line">vnode.data.keepAlive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>首先获取组件的 key 值：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key =</span><br><span class="line">  vnode.key == <span class="literal">null</span></span><br><span class="line">    ? componentOptions.Ctor.cid +</span><br><span class="line">      (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&quot;&quot;</span>)</span><br><span class="line">    : vnode.key;</span><br></pre></td></tr></table></figure><ul><li>拿到 key 值后去 this.cache 对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */</span></span><br><span class="line"><span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">  vnode.componentInstance = cache[key].componentInstance;</span><br><span class="line">  <span class="comment">/* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */</span></span><br><span class="line">  remove(keys, key);</span><br><span class="line">  keys.push(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接从缓存中拿<code>vnode</code>的组件实例，此时重新调整该组件 key 的顺序，将其从原来的地方删除掉并重新放在 this.keys 中最后一个。</li><li>如果 this.cache 对象中没有该 key 值：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 如果没有命中缓存，则将其设置进缓存 */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cache[key] = vnode</span><br><span class="line">    keys.push(key)</span><br><span class="line">    <span class="comment">/* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="built_in">this</span>.max)) &#123;</span><br><span class="line">        pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="built_in">this</span>._vnode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表明该组件还没有被缓存过，则以该组件的 key 为例，组件 vnode 为值，将其存入 this.cache 中，并且把 key 存入 this.keys 中。此时，再判断 this.keys 中缓存组件的数量是否超过了设置的最大缓存数量值 this.max，如果超过了，则把第一个缓存组件删除。</p><blockquote><p>问题：为什么要删除第一个缓存组件并为什么命中缓存了还要调整组件 key 的顺序？</p></blockquote><blockquote><p>答：这其实应用了一个缓存淘汰策略 LRU。</p></blockquote><h3 id="LRU-算法">LRU 算法</h3><p>LRU（最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过 ，那么将来被访问的几率也更高”。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1669539855977-f44fffe7-d88d-4394-9221-e3ddcd65fec3.png#averageHue=%23f3f3f3&amp;clientId=ubef7bb93-9c10-4&amp;from=paste&amp;id=ueca676fc&amp;originHeight=438&amp;originWidth=1202&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32668&amp;status=done&amp;style=none&amp;taskId=uc61d75db-aac1-4286-bf09-c689a4bfffd&amp;title=" alt="image.png"></p><ol><li>将新数据从尾部插入到 this.keys 中；</li><li>每当缓存命中（即缓存数据被访问），则将数据移到 this.keys 的尾部。</li><li>当 this.keys 满时，将头部的数据丢弃</li></ol><p>LRU 核心：如果数据最近被访问过，那么将来被访问的几率也更高，所以我们将命中缓存的组件 key 重新插入到 this.keys 的尾部，这样一来，<code>this.keys</code>中越往头部的数据即将被访问几率越低，所以当缓存数量达到最大值时，我们就删除将来被访问几率最低的数据，即 this.keys 中第一个缓存的组件。 这也是 <strong>已缓存组件中最久没有被访问的实例</strong>会被销毁的原因。</p><p>以上工作做完后，设置<code>vnode.data.keepAlive = true</code>，最后将<code>vnode</code>返回。</p><h2 id="生命周期钩子">生命周期钩子</h2><p>组件一旦被<code>&lt;keep-alive&gt;</code>缓存，那么再次渲染时，就不会执行 created、mounted 等钩子函数，但我们很多业务场景都是希望被缓存的组件再次被渲染时做一些事情。<br>Vue 提供了这两个钩子函数： <code>activated</code> 和<code>deactivated</code>。它的执行时机是：<code>&lt;keep-alive&gt;</code>包裹的组件激活时调用和停用时调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;div class=&quot;a&quot;&gt;&#x27;</span> + <span class="string">&quot;&lt;p&gt;A Comp&lt;/p&gt;&quot;</span> + <span class="string">&quot;&lt;/div&gt;&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Comp A mounted&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Comp A activated&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">deactivated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Comp A deactivated&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> B = &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;div class=&quot;b&quot;&gt;&#x27;</span> + <span class="string">&quot;&lt;p&gt;B Comp&lt;/p&gt;&quot;</span> + <span class="string">&quot;&lt;/div&gt;&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;B&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Comp B mounted&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Comp B activated&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">deactivated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Comp B deactivated&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  template:</span><br><span class="line">    <span class="string">&quot;&lt;div&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;&lt;keep-alive&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&#x27;&lt;component :is=&quot;currentComp&quot;&gt;&#x27;</span> +</span><br><span class="line">    <span class="string">&quot;&lt;/component&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;&lt;/keep-alive&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&#x27;&lt;button @click=&quot;change&quot;&gt;switch&lt;/button&gt;&#x27;</span> +</span><br><span class="line">    <span class="string">&quot;&lt;/div&gt;&quot;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentComp: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">change</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentComp = <span class="built_in">this</span>.currentComp === <span class="string">&quot;A&quot;</span> ? <span class="string">&quot;B&quot;</span> : <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    A,</span><br><span class="line">    B,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS为什么要进行变量提升？</title>
      <link href="/posts/39d6d863a942/"/>
      <url>/posts/39d6d863a942/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="1-变量提升如何体现？">1.变量提升如何体现？</h2><p>变量提升通常发生在 var 声明的变量里，使用 var 声明一个变量时，该变量会被提升到作用域的顶端，但是赋值的部分并不会被提升。<br><strong>原理：</strong></p><ol><li>JS 引擎工作方式：先解析代码，获取所有被声明的变量</li><li>然后再运行。</li></ol><h2 id="2-为什么要进行变量提升？">2.为什么要进行变量提升？</h2><p>首先，我们知道 JS 拿到一个变量时会进行解析和执行。</p><ul><li>在解析阶段，JS 会检查语法，并对函数进行预编译。解析时会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为 undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局上下文环境类似，不过函数上下文会多出 this、arguments 和函数的参数。<ul><li>全局上下文：变量定义、函数声明</li><li>函数执行上下文：变量定义、函数声明、this、arguments</li></ul></li><li>在执行阶段，按照代码的顺序依次执行</li></ul><p>为什么会进行变量提升？</p><ul><li>提高性能</li><li>容错性更好</li></ul><h3 id="（1）提高性能">（1）提高性能</h3><ul><li>JS 代码执行之前，会进行<strong>语法检查和预编译</strong>，并且这一操作只进行一次。</li></ul><p>这样做是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新编译一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p><ul><li>在<strong>解析</strong>的过程中，还会为函数<strong>生成预编译代码</strong>。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，取出注释、不必要的空白等。好处：每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量、创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</li></ul><h3 id="（2）容错性更好">（2）容错性更好</h3><p>变量提升可以在一定程度上提高 JS 的容错性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。<br>虽然，我们可以在开发过程中，可以完全避免这样写，但是有时候很复杂时，可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p><h3 id="总结：">总结：</h3><ul><li><strong>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间。</strong></li><li><strong>声明提升还可以提高 JS 代码的容错性，使得一些不规范的代码也可以正常运行。</strong></li></ul><h2 id="3-变量提升导致的问题">3.变量提升导致的问题</h2><p>变量提升虽然有一些优点，但是也会造成一些问题，在 ES6 中提出了 let、const 来定义变量，它们就没有变量提升的机制。<br>变量提升会导致的问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">//  undefined</span></span><br></pre></td></tr></table></figure><p>在这个函数中，原本是要打印出外层的 tmp 变量，但是因为变量提升的问题，内层定义的 tmp 被提到哈函数内部的最顶部，相当于覆盖了最外层的 tmp，所以打印结果为 undefined。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>由于遍历时定义的 i 会变量提升为一个全局变量，在函数结束后，不会被销毁，所以打印出来 11.</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS高频面试题</title>
      <link href="/posts/d619a15d8905/"/>
      <url>/posts/d619a15d8905/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="apply、call、bind-的区别">apply、call、bind 的区别</h2><ul><li>三者都可以改变函数的 this 对象指向</li><li>三者第一个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 null，则默认指向全局 window</li><li>三者都可以传参，但是 apply 是数组，而 call 是参数列表，且 apply 和 call 是一次性传入参数，而 bind 可以分为多次传入</li><li>bind 是返回绑定 this 之后的函数，需要手动执行函数，apply、call 则是立即执行</li></ul><h2 id="new-操作符的实现原理">new 操作符的实现原理</h2><p>new 操作符的执⾏过程：<br>（1）⾸先创建了⼀个新的空对象<br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>（3）让函数的 this 指向这个对象，执⾏构造函数的代码（为这个新对象添加属性）<br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引⽤类型，就返回这个引⽤类<br>型的对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title">constructor</span> = <span class="title">Array</span>.<span class="title">prototype</span>.<span class="title">shift</span>.<span class="title">call</span>(<span class="params"><span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是⼀个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title">constructor</span> !== &quot;<span class="title">function</span>&quot;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建⼀个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="built_in">Object</span>.create(<span class="title">constructor</span>.<span class="title">prototype</span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执⾏函数</span></span><br><span class="line">  result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">newObject, <span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag =</span><br><span class="line">    result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使⽤⽅法</span></span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure><h2 id="map-和-foreach-的区别">map()和 foreach()的区别</h2><h3 id="简洁回答">简洁回答</h3><p>都是⽤来遍历数组的，两者区别如下：</p><ul><li>forEach()⽅法会针对每⼀个元素执⾏提供的函数，对数据的操作会改变原数组，该⽅法没有返回</li></ul><p>值；</p><ul><li>map()⽅法不会改变原数组的值，返回⼀个新数组，新数组中的值为原数组调⽤函数处理之后的</li></ul><p>值；</p><h3 id="相同点">相同点</h3><ol><li>都是循环遍历数组的每一项</li><li>都相当于封装好的单层 for 循环，三个值都相同</li><li>每次执行匿名函数都支持三个参数，参数分别为 item（当前每一项）、index（索引值）、arr（原数组）</li><li>匿名函数中的 this 都是指向 window</li><li>只能遍历数组</li></ol><h3 id="不同点">不同点</h3><ul><li>map()会分配内存空间存储新数组并有返回值，forEach()没有返回值</li><li>forEach()允许 calllback 更改原始数组的元素，map()返回新的数组，map()不会对空数组进行检测</li><li>forEach()遍历通常都是直接引入当前遍历数组的内存地址，生成的数组的值发生变化，当前遍历的数组对应的值也会发生变化。</li><li>map 遍历后的数组通常会生成一个新的数组，新数组的值发生变化，当前遍历的数组值不会变化。</li><li>map 的速度大于 forEach</li></ul><h3 id="使用场景">使用场景</h3><ol><li>forEach()适用于你并不打算改变数据的时候</li><li>map()适用于你要改变数据的时候。不仅在于它更快，而且返回一个新数组。（因此可以使用复合（composition）（map(),filter(),reduce()等组合使用））</li></ol><p>性能上来说，for&gt;forEach&gt;map。</p><h2 id="Symbol">Symbol</h2><ol><li>什么是 Symbol？</li></ol><p>Symbol 是 ES6 新增的一种数据类型，被划分为<strong>基本数据类型</strong>。不能用 <code>new</code>。</p><ul><li>基本数据类型：字符串、数值、布尔、undefined、null、Symbol。</li><li>引用数据类型：Object</li></ul><ol start="2"><li>作用</li></ol><p>用来表示一个独一无二的值。</p><ol start="3"><li>格式：<code>let xxx = Symbol('标识字符串')</code></li><li>为什么需要 Symbol？</li></ol><p>为了避免第三方框框架的同名属性被覆盖。</p><blockquote><p>在企业开发中，如果需要对一些第三方的插件、框架进行自定义时，可能会因为添加了同名的属性或方法，将框架中原有的属性或方法覆盖掉，为了避免这种情况的发生，框架的作者告诉我们就可以使用 Symbol 作为属性或方法的名称。</p></blockquote><ol start="5"><li>如果区分 Symbol？</li></ol><p>在通过 Symbol 生成一个独一无二的值时，可以设置一个标记<br>这个标记仅仅用于区分，没有其他任何意义。</p><ol start="6"><li>如果特殊情况需要读取这个标记，</li></ol><ul><li>Symbol 类型可以转化为 boolean 或字符串，转化为字符串时前面会加上 Symbol(wxy)，不方便</li><li>可以直接通过 description 属性获取 Symbol 函数的字符串标识参数</li></ul><ol start="7"><li>使用 Symbol 类型作为属性名<blockquote><p>对象的属性要么是字符串，要么是 Symbol 类型</p></blockquote></li></ol><ul><li>默认是字符串，所以不加<code>&quot;&quot;</code>也可以；如果需要类型为 Symbol，需要使用<code>[]</code>。</li><li>不能用<code>.</code>来访问，因为点运算符后面总是字符串。</li><li>Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</li></ul><ol start="8"><li>例子：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后面的括号可以给symbol做上标记便于识别</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="built_in">Symbol</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> say = <span class="built_in">Symbol</span>(<span class="string">&quot;say&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">//如果想 使用变量作为对象属性的名称，必须加上中括号，.运算符后面跟着的都是字符串</span></span><br><span class="line">  [name]: <span class="string">&quot;lnj&quot;</span>,</span><br><span class="line">  [say]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// name: &quot;rose&quot;,</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// obj.name = &quot;it6661&quot;;</span></span><br><span class="line">obj[<span class="built_in">Symbol</span>(<span class="string">&quot;name&quot;</span>)] = <span class="string">&quot;it666&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj));</span><br></pre></td></tr></table></figure><blockquote><p>{<br>[Symbol(name)]: ‘lnj’,<br>[Symbol(say)]: [Function: [say]],<br>[Symbol(name)]: ‘it666’<br>}<br>[ Symbol(name), Symbol(say), Symbol(name) ]</p></blockquote><p>没有覆盖原来的 name，因为都是独一无二的，那么就默认创建一个 name 的属性。</p><h3 id="注意点">注意点</h3><ol><li>Symbol 是基本数据类型，不能加 new</li><li>后面括号可以传入一个字符串，只是一个标记，方便阅读，没有任何意义。</li><li>类型转化的时候，不可转化为数值，只能转化为字符串和布尔值。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(name));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(name));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(name)); <span class="comment">// Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure><ol start="4"><li>不能做任何运算</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="built_in">Symbol</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(name + <span class="number">111</span>);</span><br><span class="line"><span class="built_in">console</span>.log(name + <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"><span class="comment">//全部报错 Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure><ol start="5"><li>Symbol 生成的值作为属性或方法的时候，一定要保存下来，否则后续无法使用。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="built_in">Symbol</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">// name:&#x27;lnj&#x27;,</span></span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&quot;name&quot;</span>)]: <span class="string">&quot;lbj&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">//访问不到，因为  [Symbol(&#x27;name&#x27;)]又是一个新的值，和上面的name不是同一个</span></span><br></pre></td></tr></table></figure><p>应该改为如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="built_in">Symbol</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [name]: <span class="string">&quot;lnj1&quot;</span>,</span><br><span class="line">  <span class="comment">// [Symbol(&quot;name&quot;)]: &quot;lbj&quot;,</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// console.log(obj.name); //访问不到，因为  [Symbol(&#x27;name&#x27;)]又是一个新的值，和上面的name不是同一个</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj));</span><br><span class="line"><span class="built_in">console</span>.log(obj[name]);</span><br></pre></td></tr></table></figure><blockquote><p>[ Symbol(name) ]<br>lnj1</p></blockquote><ol start="6"><li>for 循环遍历对象时无法遍历出 Symbol 的属性和方法</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="built_in">Symbol</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [name]: <span class="string">&quot;lnj&quot;</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  teacher: <span class="string">&quot;wyx&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">//只能打印出age和teacher</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个方法可以单独取出Symbol(name)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj));</span><br></pre></td></tr></table></figure><h3 id="Symbol-的应用">Symbol 的应用</h3><ol><li>在企业开发中，如果需要对一些第三方的插件、框架进行自定义时，可能会因为添加了同名的属性或方法，将框架中原有的属性或方法覆盖掉，为了避免这种情况的发生，框架的作者告诉我们就可以使用 Symbol 作为属性或方法的名称。</li><li>消除魔术字符串<blockquote><p>魔术字符串：在代码中多次出现，与代码形成强耦合的某一个具体的字符串或数值。风格良好的代码应该尽量消除魔术字符串，改由含义清晰的变量代替。‘</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gender = &#123;</span><br><span class="line">  <span class="comment">//这样就说明man就是一个独一无二的值，不用再man:&#x27;man&#x27;</span></span><br><span class="line">  man: <span class="built_in">Symbol</span>(),</span><br><span class="line">  woman: <span class="built_in">Symbol</span>(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMan</span>(<span class="params">gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (gender) &#123;</span><br><span class="line">    <span class="keyword">case</span> gender.man:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;男性&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> gender.woman:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;女性&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">isMan(gender.man); <span class="comment">//男性</span></span><br></pre></td></tr></table></figure><ol start="3"><li>为对象定义一些非私有的、但又希望只用于内部的方法。<blockquote><p>由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。<br>注意：Symbol 并不能实现真正的私有变量的效果，只是不能通过常规的遍历方法拿到 Symbol 类型的属性而已。</p></blockquote></li></ol><p><strong>对象的遍历方法</strong>：</p><ul><li>for(let xx in obj)：i 代表 key</li><li>for(let xx of obj)：不是自带的</li><li>Object.keys(obj)：返回包含的 key 的数组</li><li>Object.values(obj)：返回包含 value 的数组</li><li>Object.getOwnPropertyNames()：返回包含 key 的数组</li></ul><p>上述的所有方法都遍历不到 Symbol 类型的（注意：是遍历时取不到 Symbol，并不是我们访问不到对象的 Symbol 类型）<br><strong>可以遍历到 Symbol 的方法：</strong></p><ul><li><strong>Object.getOwnPropertySymbols()</strong>：返回对象中只包含 Symbol 类型 key 的数组</li><li><strong>Reflect.ownKeys()</strong>：返回对象中所有类型 key 的数组（包含 Symbol）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _password = <span class="built_in">Symbol</span>(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">  [_password]: <span class="string">&quot;11038&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj));</span><br><span class="line"><span class="comment">// 输出11038，所以还是可以直接访问到symbol类型的属性，所以symbol并不能真正实现私有变量的设定，所以一般只用于定义一些非私有的、但又希望只用于内部的方法</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[_password]);</span><br></pre></td></tr></table></figure><p>输出如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1668653745915-fc9503cf-b3b8-4973-b078-26b09f69ba22.png#averageHue=%23212121&amp;clientId=u2b09cbdb-2331-4&amp;from=paste&amp;height=116&amp;id=u196ca470&amp;originHeight=245&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=46307&amp;status=done&amp;style=none&amp;taskId=uda6b3e15-79e2-4aa7-982d-49fe7eb8eb8&amp;title=&amp;width=275" alt="image.png"></p><h3 id="Symbol-自带的方法">Symbol 自带的方法</h3><h4 id="1-Symbol-for">1. <code>Symbol.for()</code></h4><p>重新使用同一个 Symbol 值。<br>接收一个字符串作为参数，搜索是否有以该参数作为名称的 Symbol 值，如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="2-Symbol-keyFor">2. <code>Symbol.keyFor()</code></h4><p>返回一个已登记的 Symbol 类型值的<code>key</code>。<br>由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="Map-和-Object-区别">Map 和 Object 区别</h2><table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>意外的键</td><td>Map 默认情况不包含任何键，只包含显式插入的键</td><td>Object 有一个原型，原型链上的键名有可能和自己在对象上设置的键名有冲突</td></tr><tr><td>键的类型</td><td>Map 的键可以是<strong>任意值</strong>，包括函数、对象或任意基本类型</td><td>Object 的键必须是<strong>String 或 Symbol</strong></td></tr><tr><td>键的顺序</td><td>Map 中的<strong>key</strong>是<strong>有序</strong>的。因此，当迭代的时候，Map 对象以<strong>插入的顺序</strong>返回键值</td><td>Object 的键是<strong>无序</strong>的</td></tr><tr><td>Size</td><td>Map 的键值对个数可以轻易地通过<strong>size</strong>属性获取</td><td>Object 建值对个数只能<strong>手动计算</strong></td></tr><tr><td>迭代</td><td>Map 是 iterable 的，所以可以<strong>直接被迭代</strong></td><td>迭代 Object 需要以某种方式<strong>获取它的键然后才能迭代</strong></td></tr><tr><td>性能</td><td>在频繁增删键值对的场景下表现更好</td><td>在频繁添加和删除键值对的场景下<strong>未做出优化</strong></td></tr></tbody></table><h2 id="Map-和-WeakMap-区别">Map 和 WeakMap 区别</h2><h3 id="Map">Map</h3><p>map 本质上是键值对的集合，但是普通 Object 的中的键值只能是字符串或 Symbol。而 ES6 提供的 Map 数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的 Hash 结构。如果 Map 的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。<br>实际上 Map 是一个数组，它的每一个数据也都是一个数组，其形式如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = [</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;age&quot;</span>, <span class="number">18</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>Map 数据结构有以下操作方法：</p><ul><li>size：<code>map.size()</code>返回 Map 结构的成员总数</li><li>set(key,value)：设置键名 key 对应的键值 value，然后返回整个 Map 结构，如果 key 已经有值，则键值会被更新，否则就生成该键。（因为返回的是当前 Map 对象，所以可以链式调用）</li><li>get(key)：该方法读取 key 对应的键值，如果找不到 key，返回 undefined</li><li>has(key)：该方法返回一个布尔值，表示某个键是否在当前 Map 对象中。</li><li>delete(key)：该方法删除某个 key，返回 true，如果删除失败，返回 false。</li><li>clear()：map.clear() 清除所有成员，没有返回值</li></ul><p>Map 结构原生提供是三个遍历器生成函数和一个遍历方法</p><ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回所有成员的遍历器</li><li>forEach()：遍历 Map 的所有成员</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&quot;bar&quot;</span>, <span class="number">2</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// foo bar</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> items <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(items); <span class="comment">// [&quot;foo&quot;,1] [&quot;bar&quot;,2]</span></span><br><span class="line">&#125;</span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value); <span class="comment">// foo 1 bar 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="WeakMap">WeakMap</h3><p>WeakMap 对象也是一组键值对的集合，其中的键是<strong>弱引用</strong>。**其键必须是对象，**原始数据类型不能作为 key 值，而值可以是任意的。<br>该对象也有以下几种方法：</p><ul><li><strong>set(key,value)</strong>：设置键名 key 对应的键值 value，然后返回整个 Map 结构，如果 key 已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前 Map 对象，所以可以链式调用）</li><li><strong>get(key)</strong>：读取 key 对应的键值，如果找不到 key，返回 undefined。</li><li><strong>has(key)</strong>：返回一个布尔值，表示某个键是否在当前 Map 对象中。</li><li><strong>delete(key)</strong>：删除某个键，返回 true，如果删除失败，返回 false。</li></ul><p>其 clear() 方法已经被弃用，所以可以通过创建一个空的 WeakMap 并替换原对象来实现清除。<br><strong>WeakMap 的设计目的</strong>：</p><ul><li>有时想在某个对象上存放一些数据，但是这会形成对于这个对象的引用。一旦不需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。</li><li>而 WeakMap 的<strong>键名所引用的对象都是弱引用</strong>， 即**垃圾回收机制不将该引用考虑在内。**因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。即一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，<strong>不用手动删除引用</strong>。</li></ul><h3 id="总结">总结</h3><ul><li>Map 数据结构，类似于对象，也是键值对的集合，但是“键”的范围<strong>不限于</strong>字符串，各种类型的值（包括对象）都可以作为键。</li><li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap<strong>只接受对象作为键名</strong>（null 除外），不接受其他类型的值作为键名。<strong>而且 WeakMap 的键名所指向的对象是弱引用，不计入垃圾回收机制。</strong></li></ul><h2 id="JS-内置对象">JS 内置对象</h2><p>全局的对象（global objects）或称标准内置对象。即全局作用域中的对象，全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><h3 id="标准内置对象的分类">标准内置对象的分类</h3><ol><li>值属性：这些全局属性返回一个简单值，这些值没有自己的属性和方法。</li></ol><p>如：Infinity、NaN、undefined、null 字面量。</p><ol start="2"><li>函数属性：全局属性可以直接调用，不需要再调用时指定所属对象，执行结束后会将结果直接返回给调用者。</li></ol><p>如：eval()、parseFloat()、parseInt()等。</p><ol start="3"><li>基本对象：是定义或使用其他对象的基础。包括一般对象、函数对象和错误对象。</li></ol><p>如：Object、Function、Boolean、Symbol、Error 等。</p><ol start="4"><li>数字和日期对象：用来表示数字、日期和执行数学计算的对象。</li></ol><p>如：Number、Math、Date。</p><ol start="5"><li>字符串：用来表示和操作字符串的对象。</li></ol><p>如：String、RegExp</p><ol start="6"><li>可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。</li></ol><p>如：Array。</p><ol start="7"><li>使用键的集合对象：这些集合对象在存储时会使用到键，支持按照插入顺序来迭代元素。</li></ol><p>如：Map、Set、WeakMap、WeakSet。</p><ol start="8"><li>矢量集合：SIMD 矢量集合中的数据会被组织为一个数据序列。</li></ol><p>如：SIMD 等。</p><ol start="9"><li>结构化数据：这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</li></ol><p>如：JSON 数据。</p><ol start="10"><li>控制抽象对象。如：Promise、Generator 等。</li><li>反射。如：Reflect、Proxy。</li><li>国际化：为了支持多语言处理而加入的 ECMAScript 的对象。</li></ol><p>如：Intl、Intl.Collator 等。</p><ol start="13"><li>WebAssembly</li><li>其他。如 arguments</li></ol><h3 id="总结-v2">总结</h3><ol><li>JS 中的内置对象主要指的是在程序执行前存在全局作用域中的由 JS 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。</li><li>一般经常用到的如 全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数 如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象等。</li></ol><h2 id="JS-脚本延迟加载的方式">JS 脚本延迟加载的方式</h2><ul><li>defer：异步加载，延迟执行（html 加载完再执行）</li><li>async：异步加载，加载完立即执行（会阻塞 html 页面解析）</li><li>动态创建 DOM 方式：对文档加载事件进行监听，当文档加载完后，再动态创建 script 标签来引入 JS 脚本。</li><li>setTimeout 延迟方法：设置一个定时器来延迟加载 JS 脚本文件</li><li>让 JS 最后加载：将 JS 脚本文件放在文档底部，来使 JS 脚本尽可能最后加载执行。</li></ul><h2 id="JS-类数组对象">JS 类数组对象</h2><p>JS 类数组对象：一个拥有 length 属性和若干索引属性的对象。<br>和数组类似，但不能调用数组的方法。<br>常见的类数组对象有：</p><ul><li>argument 和 DOM 方法的返回结果</li><li>函数（因为含有 length 属性值，代表可接收的参数个数）</li></ul><p>类数组转换为数组的方法：</p><ol><li>通过 call 调用数组的 slice 方法来实现转换</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure><ol start="2"><li>通过 call 调用数组的 splice 方法来实现转换</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>通过 apply 调用数组的 concat 方法来实现转换</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure><ol start="4"><li>通过 Array.from() 实现转换</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure><h2 id="数组有哪些原生方法">数组有哪些原生方法</h2><ul><li>数组和字符串的转换方法：toString()、toLocalString()、join()，其中 join()可以指定转换为字符串时的分隔符</li><li>数组尾部操作的方法：pop()和 push()，push() 方法可以传入多个参数</li><li>数组首部操作的方法：shift() 删除和 unshift() 添加</li><li>重排序的方法：reverse() 和 sort()，sort() 可传入一个函数进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置</li><li>数组连接：concat() 返回拼接好的数组，不影响原数组。</li><li>数组截取：splice()</li><li>影响原数组特定项的索引的方法，indexOf()和 lastIndexOf()</li><li>迭代方法：every()、some()、filter()、map()、forEach()方法</li><li>数组归并方法：reduce()、reduceRight()方法</li></ul><h2 id="Promise-race-应用场景">Promise.race() 应用场景</h2><blockquote><p>race() 和 all() 一样，接受的参数是一个每项都是 Promise 的数组，但是与 all 不同的是，当<strong>最先执行完</strong>的事件执行完后，就直接返回该 promise 对象的值。<br>如果第一个 promise 对象状态变成 resolved，则自身的状态就变成了 resolved；反之，第一个 promise 变成 rejected，则自身状态就会变成 rejected。</p></blockquote><p><strong>Promise.race() 应用场景</strong>：</p><ul><li>http 请求时，做超时判断时，设置一个定时器，当定时器时间到了时间就在页面提醒请求超时。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求某个图片资源</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestImg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = <span class="string">&quot;http://www.baidu.com/img/flexiable/logo/pc/result.png&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 延时函数，用于给请求计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="string">&quot;图片请求操时&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([requestImg(), timeout()])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise-all-应用场景">Promise.all() 应用场景</h2><blockquote><p>它可以将多个 promise 实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功时返回一个<strong>结构数组</strong>，而失败时则返回<strong>最先被 reject 失败状态的值。</strong></p></blockquote><p><strong>Promise.all() 中传入的是数组，返回的也是数组，并会进行映射，传入的 Promise 对象返回值是按照顺序在数组中排列的，但是注意他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</strong></p><blockquote><p><strong>注意：Promise.all 获得的成功结果的数组中的数据顺序和 Promise.all()接收的数组顺序是一致的，这样当遇到多个请求并根据请求顺序获取和使用数据的场景，可以使用 Promise.all 来解决。</strong></p></blockquote><h2 id="使用-requestAnimationFrame-实现一个循环定时器">使用 requestAnimationFrame 实现一个循环定时器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInterval</span>(<span class="params">callback, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now;</span><br><span class="line">  <span class="keyword">let</span> startTime = now();</span><br><span class="line">  <span class="keyword">let</span> endTime = startTime;</span><br><span class="line">  <span class="keyword">const</span> loop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    timer = <span class="built_in">window</span>.requestAnimationFrame(loop);</span><br><span class="line">    endTime = now();</span><br><span class="line">    <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">      startTime = endTime = now();</span><br><span class="line">      callback(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  timer = <span class="built_in">window</span>.requestAnimationFrame(loop);</span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">(<span class="params">timer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">3</span>) cancelAnimationFrame(timer);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>⾸先 requestAnimationFrame ⾃带函数节流功能，基本可以保证在 16.6 毫秒内只执⾏⼀次（不掉<br>帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS编译原理</title>
      <link href="/posts/6a7896f2e5d7/"/>
      <url>/posts/6a7896f2e5d7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="JS-编译原理">JS 编译原理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;rose&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面这行代码在 JS 中会这样呈现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name; <span class="comment">// 编译阶段处理</span></span><br><span class="line">name = <span class="string">&quot;rose&quot;</span>; <span class="comment">// 执行阶段处理</span></span><br></pre></td></tr></table></figure><p>JS 编译主要分为两个阶段：<strong>编译阶段和执行阶段</strong>。</p><h3 id="编译阶段">编译阶段</h3><p>此阶段主角为<strong>编译器。</strong></p><ul><li>JS 找遍作用域，看是否存在 name 的变量<ul><li>如果已经存在，则什么都不做，直接忽略<code>var name</code>这个声明，继续编译下去；</li><li>如果没有，则在当前作用域中新增一个<code>name</code>变量</li></ul></li><li>编译器会为引擎生成运行时所需的代码，程序就进入了执行阶段。</li></ul><h3 id="执行阶段">执行阶段</h3><p>此阶段主角为<strong>JS 引擎。</strong></p><ul><li><strong>JS 引擎</strong>在运行时，会先找遍当前作用域，看是否有一个叫<code>name</code>的变量。<ul><li>如果有，直接赋值</li><li>如果没有，则为当前作用域没有。则去父级作用域看是否有，如果无，则去上一级作用域中查找。</li><li>如果最终没有找到，则抛异常。<blockquote><p>作用域套作用域，即作用域链。</p></blockquote></li></ul></li></ul><h2 id="作用域">作用域</h2><p>变量最基本的能力就是<strong>能够存储变量中的值，并且允许我们对此变量进行访问和修改</strong>，而对于变量存储，访问的<strong>规则</strong>是 <strong>作用域</strong>。</p><h3 id="全局作用域">全局作用域</h3><p>在任何函数外或代码块外的顶层作用域就是全局作用域，里面的变量就是全局变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;rose&quot;</span>; <span class="comment">//全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//函数作用域</span></span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  name = <span class="string">&quot;test&quot;</span>; <span class="comment">//块级作用域</span></span><br><span class="line">&#125;</span><br><span class="line">showName(); <span class="comment">//test</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到，全局变量在全局作用域、函数作用域、块级作用域中都可以正常访问。</p></blockquote><h3 id="函数作用域">函数作用域</h3><p>在函数中的作用域就是函数作用域。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;jack&quot;</span>; <span class="comment">//函数作用域</span></span><br><span class="line">&#125;</span><br><span class="line">showName(); <span class="comment">//方法调用</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">//块级作用域,Uncaught ReferenceError: name is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//全局作用域,Uncaught ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到，函数内部变量，在全局作用域及块级作用域中，都无法访问，只有在函数内部，才能访问到，所以函数内部的变量也称为<strong>局部变量</strong>。</p></blockquote><h3 id="块级作用域">块级作用域</h3><p><code>ES6</code>中新出的<code>let</code> 和<code>const</code>关键字 自带作用域。<br>块级作用域相当于是只在这块代码块中生效，如果它被大括号<code>&#123;&#125;</code>包围，则大括号就是一段代码块，代码块中使用<code>const</code>声明的变量也被称为<strong>局部变量。</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> name=<span class="string">&#x27;rose&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">//Uncaught ReferenceError: name is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showName();    <span class="comment">//Uncaught ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到，块级作用域中的变量，在代码块外面就访问不到了。</p></blockquote><h2 id="作用域链">作用域链</h2><p><strong>作用域和作用域的嵌套，就产生了作用域链。作用域链的查找，向外不向内。</strong></p><h2 id="变量提升">变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;rose&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//rose</span></span><br><span class="line"><span class="keyword">var</span> name;</span><br></pre></td></tr></table></figure><p>可以发现，这段代码可以正常运行，并且不会报错。<br>在 JS 眼中代码实际上是这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line">name = <span class="string">&quot;rose&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// rose</span></span><br></pre></td></tr></table></figure><hr><p><code>let</code>和<code>const</code>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;rose&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//Uncaught ReferenceError: Cannot access &#x27;name&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> name;</span><br></pre></td></tr></table></figure><blockquote><p>let 、const **禁用变量提升。**const 声明后必赋值。</p></blockquote><h3 id="let、const、var-的区别">let、const、var 的区别</h3><ol><li><strong>块级作用域</strong>：块级作用域由<code>&#123;&#125;</code>包括，<code>let</code>和<code>const</code>具有块级作用域，<code>var</code>不存在块级作用域。</li></ol><p>块级作用域解决了<code>ES5</code>中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄漏为全局变量</li></ul><ol start="2"><li><strong>变量提升</strong>：var 存在变量提升，let 和 const 不存在变量提升，即变量只能在声明后使用，否则会报错。</li><li><strong>给全局添加属性</strong>：浏览器的全局对象是 window，Node 的全局变量是 global。var 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 let 和 const 不会。</li><li><strong>重复声明</strong>：var 声明变量时，可以重复声明变量，后声明的变量会覆盖之前声明的变量。let 和 const 不允许在同一作用域下重复声明变量。</li><li><strong>暂时性死区：<strong>在使用 let、const 关键字声明变量时，该变量是不可用的，这在语法上，成为</strong>暂时性死区</strong>。</li></ol><p>使用 var 声明的变量不存在暂时性死区。</p><ol start="6"><li><strong>初始值设置</strong>：在变量声明时，var 和 let 可以不用设置初始值。而 const 声明变量必须设置初始值。</li><li><strong>指针指向</strong>：let 和 const 都是 ES6 新增的用于创建变量的语法。let 创建的变量可以更改指针指向（可以重新赋值）。但 const 声明的变量不允许改变指针的指向（不允许重新赋值）。</li></ol><h2 id="暂时性死区">暂时性死区</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;rose&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  name = <span class="string">&quot;bob&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> name; <span class="comment">//Uncaught ReferenceError: Cannot access &#x27;name&#x27; before initialization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果区块中存在 let 和 const，这个区块对于这些关键字声明的变量，从一开始就形成了封闭作用域。</strong><br>因为 JS 清楚地感知到了 name 是用 let 声明在当前这个代码块内的，所以会给这个变量 name 加上了暂时性死区的限制，它就不往外探出头了。<br>因此，如果我们把上面的<code>let name;</code>去掉，程序也能正常运行，name 的值也能被成功修改为 blob，就是正常地按照<strong>作用域链</strong>的规则，向外探出头去了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么script 标签是一个宏任务</title>
      <link href="/posts/1097470d302b/"/>
      <url>/posts/1097470d302b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote><p>JS 是一门单线程的语言，因此，JS 在同一时间只能做一件事，单线程意味着，如果在同个时间有多个任务，这些任务就要排队，前一个任务执行完，才会执行下一个任务。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670897426854-c1daf2d5-449d-48a3-9264-8fc0bca3f163.png#averageHue=%23f1eff2&amp;clientId=u9fcda738-8167-4&amp;from=paste&amp;height=477&amp;id=u76ea3fa3&amp;originHeight=477&amp;originWidth=763&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=138004&amp;status=done&amp;style=none&amp;taskId=u6d065fa0-7f0c-4299-9eb1-d104661b4bd&amp;title=&amp;width=763" alt="image.png"><br>举个栗子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 脚本 <span class="number">1</span> --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;startA&#x27;</span>)</span><br><span class="line"><span class="comment">// 异步宏</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;A1&#x27;</span>), <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;A2&#x27;</span>)</span><br><span class="line">resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 异步微</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;A3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;A4&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 脚本 <span class="number">2</span> --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;startB&#x27;</span>)</span><br><span class="line"><span class="comment">// 异步宏</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;B2&#x27;</span>), <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;B2&#x27;</span>)</span><br><span class="line">resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 异步微</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;B3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end2&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">script A</span><br><span class="line">A2</span><br><span class="line">A4</span><br><span class="line">A3</span><br><span class="line">script B</span><br><span class="line">B2</span><br><span class="line">B4</span><br><span class="line">B3</span><br><span class="line">A1</span><br><span class="line">B1</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>最开始，JS 引擎将这段代码解析成两个宏任务，一个是 脚本 1，一个是 脚本 2。会把这两个宏任务放到宏任务队列中去。正常情况下，JS 执行是先微后宏，此时微任务队列中没有队列任务，就跳过，去执行宏任务。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670898463403-2dd88652-6c90-4975-9cd1-43bdb2f8db13.png#averageHue=%23f2e8e0&amp;clientId=u9fcda738-8167-4&amp;from=paste&amp;height=270&amp;id=uc96b1a6c&amp;originHeight=270&amp;originWidth=326&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=30416&amp;status=done&amp;style=none&amp;taskId=u2bdc46ca-275d-42be-bb3a-9dcdb08290e&amp;title=&amp;width=326" alt="image.png"></p><ol start="2"><li>因为 脚本 1 在上面，JS 会去先执行 脚本 1 ，然后就把 script A 压入 【调用栈】中。<ol><li>由于第一行代码是同步代码，所以先执行。</li><li>将 timer1 压入 宏任务队列中</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670899077228-3c5733f6-f95e-4e2a-9970-a4be90412ec1.png#averageHue=%23f4f0ea&amp;clientId=u9fcda738-8167-4&amp;from=paste&amp;height=254&amp;id=ua0c458ca&amp;originHeight=254&amp;originWidth=405&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=27642&amp;status=done&amp;style=none&amp;taskId=u852c97c0-9b65-4888-ad85-cf40f8a199c&amp;title=&amp;width=405" alt="image.png"></p><ol start="3"><li>new Promise() 中 p1 是 同步任务，立即执行，出栈</li><li>触发异步机制，进入 Promise.then() 中，触发回调，把 A3 加入微任务队列中去，等待执行</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670899089251-145264c4-b8bd-4736-874f-227312175e60.png#averageHue=%23f4e8e1&amp;clientId=u9fcda738-8167-4&amp;from=paste&amp;height=251&amp;id=R6c2R&amp;originHeight=251&amp;originWidth=384&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26983&amp;status=done&amp;style=none&amp;taskId=ub8561ed2-194e-44e9-ad21-535a0c2c240&amp;title=&amp;width=384" alt="image.png"></p><ol start="5"><li>此时，按照“先微后宏“的顺序， 此时，微任务队列中有任务，就把 A3 放入调用栈中执行，输出 A3，出栈（A4 是同步代码，已经在 A3 之前执行输出）</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670899704352-7528d448-b4dc-420d-bdb3-1fb3407e8caa.png#averageHue=%23f4eae4&amp;clientId=u9fcda738-8167-4&amp;from=paste&amp;height=250&amp;id=ud2893cfc&amp;originHeight=250&amp;originWidth=372&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=29144&amp;status=done&amp;style=none&amp;taskId=u9118bbad-f295-4397-a9aa-b1613dbc913&amp;title=&amp;width=372" alt="image.png"><br>此时，微任务队列中没有任务了，事件循环会跳过微任务，去执行宏任务。会把 script B 调入调用栈中去（不是全部一下子调入调用栈中的，是按照代码先后顺序去逐行调入的）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670900133149-a369a583-4d6c-469c-9aa3-e37405606f13.png#averageHue=%23f4f1eb&amp;clientId=u9fcda738-8167-4&amp;from=paste&amp;height=256&amp;id=u3fd88008&amp;originHeight=256&amp;originWidth=369&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=27544&amp;status=done&amp;style=none&amp;taskId=u3b91c160-41f3-40d9-8c39-c6a287ecbdb&amp;title=&amp;width=369" alt="image.png"></p><ol start="3"><li>将 B1 这个宏任务加入到宏任务队列中去</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670900387253-a76291b9-45b6-4c70-a4d0-5834ec85fe36.png#averageHue=%23f3eae4&amp;clientId=u9fcda738-8167-4&amp;from=paste&amp;height=269&amp;id=ua16f381a&amp;originHeight=269&amp;originWidth=386&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=28521&amp;status=done&amp;style=none&amp;taskId=u4fa9cd4e-a7b0-4776-9536-70d33baf4a2&amp;title=&amp;width=386" alt="image.png"></p><ol start="4"><li>B2 是同步代码，加入调用栈中，执行，输出， 出栈；输出 B4，scriptB 宏任务就结束了，调用栈清空。</li><li>触发异步回调 Promise.then()，将 B3 加入到微任务队列中去。</li><li>此时，如图 6，按照先微后宏的顺序，会依次把 B3、A1、B1 输出。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670900756939-879e78a1-0df5-4020-8635-691925a5e40a.png#averageHue=%23f5f4f0&amp;clientId=u9fcda738-8167-4&amp;from=paste&amp;height=251&amp;id=u3872b20d&amp;originHeight=251&amp;originWidth=366&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25361&amp;status=done&amp;style=none&amp;taskId=u072a3081-7700-4e2e-9b97-1ad6333f86a&amp;title=&amp;width=366" alt="image.png"></p><h3 id="总结">总结</h3><script>标签是一个宏任务，因为这是一个代码段的入口，且必须要加载。#### 为什么JS的微任务优先于宏任务？<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;X-UA-Compatible&quot;</span> content=<span class="string">&quot;IE=edge&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="number">1</span>) </span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">rej</span>)=&gt;</span>rej(<span class="number">2</span>)).then(<span class="function">(<span class="params">data</span>)=&gt;</span></span><br><span class="line">            <span class="built_in">console</span>.log(data)</span><br><span class="line">        )</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>实际上JS会先执行一个宏任务，再执行微任务，但是为什么微任务会先执行呢？其实真正造成微任务优先级大于宏任务，是因为script本身就是一个宏任务，所以会先执行script这个宏任务，这个宏任务执行完又添加了一个宏任务（计时器），一个微任务（promise），但是执行完一个宏任务，该执行当前所有的微任务，所以先输出2，执行完微任务，再去循环调用，再执行一个宏任务，也就是定时器，执行完，发现微任务为空，就暂停，等待任务的到来，这就是事件循环的原理eventloop。所以，在做一些面试题的过程中，我们只需要记住微任务优先级大于宏任务就可以得出真正的答案。]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> eventloop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何关联本地包</title>
      <link href="/posts/bb4ec11905f1/"/>
      <url>/posts/bb4ec11905f1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="关联本地包的方式">关联本地包的方式</h2><ol><li>npm link 关联到本地(某个目录)：包更新后，本地的引用会自动更新，无需重新关联即可进行调试。</li><li>pnpm 的 <code>workspace</code> 自动关联：</li></ol><p>① 在项目根目录下创建 <code>pnpm-workspace.yaml</code> 文件 <code>yaml packages: - 'packages/\_' </code> 代表 packages 下的所有项目都可被很容易的被其他项目自动 link（无需使用 <code>pnpm i 包名</code>），底下声明的文件夹都可成为 <code>workspace</code>。<br>② 举例：如果我们想要在 <code>packages</code> 下的 <code>test</code> 中关联 <code>test2</code>，只需在 <code>test</code> 中的 <code>package.json</code> 中依赖加入对应的 <code>workspace</code> 下的项目即可， <code>json &quot;dependencies&quot;: &#123; &quot;test2&quot;: &quot;workspace:_&quot; &#125; </code> 然后在 test 下执行<code>pnpm i</code>，就会自动关联 test2 到 test1 了。<br>③ 实现步骤 2 的另一种做法：在 <code>test</code> 下执行 <code>pnpm i test2</code>，即可将 <code>test2</code> 关联到 <code>test</code>，可以看到版本号后出现<code>workspace</code>字样。</p>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
            <tag> 组件库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm与pnpm之对比</title>
      <link href="/posts/132f120904c7/"/>
      <url>/posts/132f120904c7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="pnpm-中的问题">pnpm 中的问题</h2><ul><li>pnpm 的出现对于 npm 和 yarn 来说是一个比较彻底的改变，解决了很多 npm 安装依赖存在的问题，node_modules 过大、幽灵依赖。</li><li>pnpm 目前存在的限制在于它修改了文件的相对位置，将包和其依赖放在同一个 node_modules 下，这让一些使用了绝对路径和幽灵依赖的包在使用 pnpm 安装时会存在问题，不过 pnpm 也在解决这个问题，即通过软链接的形式将所有非工程直接依赖的包放在 .pnpm/node_modules 下，这样就解决了找不到包的问题，项目在迁移 pnpm 的话尽量可能会发现 pnpm i 后还有未安装的包，这个时候就要考虑是否引用了幽灵依赖。</li></ul><h2 id="总结">总结</h2><p>pnpm 目前对于日常使用完全没问题，目前很多的类库还有框架都已经默认将 pnpm 作为安装工具，目前看来 pnpm 完全可以取代 npm。</p>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite vs Webpack vs esbuild</title>
      <link href="/posts/68e3bf681ebc/"/>
      <url>/posts/68e3bf681ebc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>Vite 和 Webpack 之对比</h1><p>开发阶段：Vite 的速度远快于 Webpack<br>主要原因：<strong>Webpack 是先打包再启动开发服务器，Vite 是直接启动开发服务器，然后按需编译依赖文件。</strong><br>详细过程：</p><ol><li>webpack 先打包，再启动开发服务器，请求服务器时直接给予打包后的结果；</li><li>Vite 直接启动开发服务器，请求哪个模块再对哪个模块进行实时编译；</li><li>由于现代浏览器本身就支持 ES Modules，会主动发起请求去获取所需文件。Vite 充分利用这一点，将开发环境下的模块文件，作为浏览器要执行的文件，而不是像 webpack 先打包，交给浏览器执行的文件是打包后的；</li><li>由于 Vite 启动时无需打包，也就无需分析模块依赖、编译，所以启动速度非常快。当浏览器请求需要的模块时，再对模块进行编译，这种按需动态编译的模式，极大地缩短了编译时间，当项目越大，文件越多，Vite 的开发时优势越明显；</li><li>在 HRM 方面，当某个模块内容改变时，让浏览器去重新请求该模块即可，而不是像 webpack 重新将该模块的所有依赖重新编译；</li><li>当需要打包到生产环境时，Vite 使用传统的 rollup 进行打包，所以，vite 的优势体现在开发阶段，另外，由于 vite 使用的是 ES Module，所以代码中不可以使用 CommonJS。</li></ol><h1>Vite 为什么“快”？</h1><h2 id="问题现状">问题现状</h2><h3 id="1-ES-模块化支持的问题">1. ES 模块化支持的问题</h3><ul><li>以前的浏览器不支持 ES Module</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&quot;./add.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; sub &#125; <span class="keyword">from</span> <span class="string">&quot;./sub.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sub = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</span><br></pre></td></tr></table></figure><p>这样的一段代码放在浏览器不能直接运行。<br>解决方案：可以使用打包工具（如 Webpack、Rollup、Parcel），将 index.js、add.js、sub.js 这三个文件打包在一个 bundle.js 文件中，然后在项目<code>index.html</code>中直接引入<code>bundle.js</code>，从而达到代码效果。</p><h3 id="2-项目启动与代码更新的问题">2. 项目启动与代码更新的问题</h3><ul><li>项目启动：随着项目越来越大，启动一个项目可能需要几分钟</li><li>代码更新：随着项目越来越大，修改一小段代码，保存后都要等待几秒才更新</li></ul><h2 id="解决问题">解决问题</h2><h3 id="1-解决启动项目缓慢">1. 解决启动项目缓慢</h3><p>Vite 在打包时，将模块分成两个区域<code>依赖</code>和<code>源码</code>：</p><ul><li>依赖：一般是那种在开发中不会改变的 JS，比如组件库，或者一些较大的依赖（可能有上百个模块的库），这一部分使用 esbuild 来进行预构建依赖，esbuild 使用的是 Go 进行编写，比 JS 编写的打包器预构建依赖快 10-100 倍。</li><li>源码：一般是那种修改几率比较大的文件，例如 JSX、CSS、Vue 这些需要转换且时常会被修改编辑的文件。同时这些文件不是一下子全部加载，而是可以按需加载（例如路由懒加载）。Vite 会将文件转换后，以<code>ES Module</code>的方式直接交给浏览器，因为现在的浏览器大多数都直接支持 es module，这使性能提高很多。</li></ul><p>原因如下图：<br>第一张图，是以前的打包模式，<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1668606127115-567c8a0b-dc4a-4546-bc92-3cd841e9ad03.png#averageHue=%232f3741&amp;clientId=u0058c815-b7e9-4&amp;from=paste&amp;height=408&amp;id=uf56b9e97&amp;originHeight=408&amp;originWidth=732&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=55374&amp;status=done&amp;style=none&amp;taskId=ubb96c9f1-fe8c-4837-83ee-2e3d29343fb&amp;title=&amp;width=732" alt="1668601120853_43F96D26-9591-4a51-926F-A76249646CD6.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vite </tag>
            
            <tag> Webpack </tag>
            
            <tag> Esbuild </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码和图编辑器技术调研</title>
      <link href="/posts/69185aa10fa1/"/>
      <url>/posts/69185aa10fa1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="代码编辑器">代码编辑器</h2><h3 id="技术选型：">技术选型：</h3><p>在线代码编辑器： CodePen、CodeSanbox、JSFiddle<br>开源框架/库：CodeMirror5</p><h2 id="图编辑器">图编辑器</h2><p>开源框架/库：</p><ul><li>LogicFlow 底层依赖 svg</li><li>AntV G6 自定义需求强、中等数据<ul><li><strong>交互方面缩放 友好</strong>（采用脏矩形渲染机制、矩阵 scale 算法）✨</li><li><strong>适合复杂定制</strong> ✨</li></ul></li><li>Sigma.js 简单样式、海量数据<ul><li>平均，基本上不会有卡顿</li><li>动作上有缓入缓出机制，隐藏了一些不自然的帧来达到流畅</li><li>适合简单交互、数据量大的场景</li></ul></li><li>vis-network 对定制化和包大小有要求、功能模块化裁剪、场景友好<ul><li>大数据交互下不太友好，有明显卡顿感</li><li>完善的模块化机制<blockquote><p>X6 与 G6 的区别：<br>X6 是图编辑引擎，特点是节点、边、等元素的定制能力非常强，经常用来构建流程图、ER 图、DAG 图、脑图等应用。G6 和 X6 是孪生兄弟，G6 更擅长于图可视化和图分析领域。</p></blockquote></li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2324645/1670741315677-e685239c-ad00-47ef-be22-fc3e97dad9e8.png#averageHue=%23f4f4f4&amp;clientId=u39fbe52f-7c5d-4&amp;from=paste&amp;height=392&amp;id=uea3aa3a7&amp;originHeight=392&amp;originWidth=714&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=134585&amp;status=done&amp;style=none&amp;taskId=ua75e1627-9791-409c-acba-1f488dee087&amp;title=&amp;width=714" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术调研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ学习笔记</title>
      <link href="/posts/26037549ee50/"/>
      <url>/posts/26037549ee50/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1630671540955-650bc67f-569a-4cef-a095-ec73a3b34897.png#clientId=uc20dad1f-a2b4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=740&amp;id=u64b4ea35&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=740&amp;originWidth=1340&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=584856&amp;status=done&amp;style=none&amp;taskId=u20a11e76-4e9c-49b4-8ca4-cc25eac0808&amp;title=&amp;width=1340#averageHue=%23efe7e7&amp;id=FmDdj&amp;originHeight=740&amp;originWidth=1340&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1630672453989-c5f9d3cf-e77f-4c3e-8a9d-173b49f0aa4c.png#clientId=uc20dad1f-a2b4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=473&amp;id=ub505e50f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=473&amp;originWidth=1544&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=451836&amp;status=done&amp;style=none&amp;taskId=u973d9d93-5ee4-44e2-9f50-b28d8e8f15e&amp;title=&amp;width=1544#averageHue=%23f6f6f6&amp;id=N1Vbj&amp;originHeight=473&amp;originWidth=1544&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1630673109375-2f65953f-32f5-4be8-9353-9d08abb6587f.png#clientId=uc20dad1f-a2b4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=794&amp;id=uce851ada&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=794&amp;originWidth=1520&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=669042&amp;status=done&amp;style=none&amp;taskId=u1e0c19d3-9eae-4ab1-9e35-b33c4bbbcd6&amp;title=&amp;width=1520#averageHue=%23b2b1b0&amp;id=zGC4d&amp;originHeight=794&amp;originWidth=1520&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="为什么要用-rabbitMQ？">为什么要用 rabbitMQ？</h2><h3 id="1-流量削峰">1. 流量削峰</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1637998719062-ee3b7961-8606-40b9-9bd6-139143630402.png#clientId=udb8aea13-24db-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=91&amp;id=u7a7d8c10&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=182&amp;originWidth=990&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=78126&amp;status=done&amp;style=none&amp;taskId=u903bdc4d-2ce4-4ac8-97d1-9cf8226327b&amp;title=&amp;width=495#averageHue=%23f3f3f3&amp;id=Ds1E5&amp;originHeight=182&amp;originWidth=990&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="2-应用解耦">2. 应用解耦</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1637998760193-a4f14c2c-a22b-4c92-b207-ae58a962577a.png#clientId=udb8aea13-24db-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=182&amp;id=u8f01ca2b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=363&amp;originWidth=1085&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=190648&amp;status=done&amp;style=none&amp;taskId=u30e77d52-0f3b-4d69-b06f-8229a9c232f&amp;title=&amp;width=542.5&amp;referrerpolicy=no-referrer#averageHue=%23f7f7f7&amp;id=hMEcn&amp;originHeight=363&amp;originWidth=1085&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="3-异步处理">3. 异步处理</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638009293978-1fde3fa6-5de6-476b-bc8f-4381749e748c.png#clientId=udb8aea13-24db-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=315&amp;id=u2602b5b4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=630&amp;originWidth=1167&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=283589&amp;status=done&amp;style=none&amp;taskId=uf5236049-2c88-4e12-b15e-7d99585efad&amp;title=&amp;width=583.5#averageHue=%23f6f6f6&amp;id=EqXpn&amp;originHeight=630&amp;originWidth=1167&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="RabbitMQ-核心部分">RabbitMQ 核心部分</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638009378104-cb162a2f-4170-4d24-99c1-4e3ee09087ae.png#clientId=udb8aea13-24db-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=284&amp;id=u45cac300&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=568&amp;originWidth=1077&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=305514&amp;status=done&amp;style=none&amp;taskId=u95a38925-5c34-45dd-bfca-d140d73dc3f&amp;title=&amp;width=538.5#averageHue=%23f8f2f1&amp;id=TB3Zf&amp;originHeight=568&amp;originWidth=1077&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="各个名词介绍">各个名词介绍</h2><h3 id="RabbitMQ-工作原理">RabbitMQ 工作原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638009501957-eb0902f3-1fa1-47d5-9bc7-8d03f6e12de0.png#clientId=udb8aea13-24db-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=257&amp;id=u79c375f5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=514&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=210068&amp;status=done&amp;style=none&amp;taskId=ue02a7c50-c563-46af-a784-5ae4c1dcdfe&amp;title=&amp;width=530#averageHue=%23efc150&amp;id=sf1J3&amp;originHeight=514&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638009567915-6084eb1d-d428-47ec-844f-b3b48c6c6d0c.png#clientId=udb8aea13-24db-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=310&amp;id=u9337433a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=619&amp;originWidth=1135&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=776522&amp;status=done&amp;style=none&amp;taskId=uced2ac5e-e117-4050-8e39-087f63ff410&amp;title=&amp;width=567.5#averageHue=%23e1dccf&amp;id=ft4q6&amp;originHeight=619&amp;originWidth=1135&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638009610891-4a5dba18-6006-41bf-a068-b2f33ed7df48.png#clientId=udb8aea13-24db-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=63&amp;id=u38d6f233&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=126&amp;originWidth=1128&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=136646&amp;status=done&amp;style=none&amp;taskId=u3dada18e-9ab8-40c9-8042-2e2f9f40306&amp;title=&amp;width=564#averageHue=%23cdc5b8&amp;id=rJuNv&amp;originHeight=126&amp;originWidth=1128&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="安装">安装</h2><p><a href="https://www.rabbitmq.com/download.html">rabbitmq.com/download.html</a><br>erlang 和 rabbitMQ 版本匹配：<br><a href="https://www.cnblogs.com/gne-hwz/p/10714013.html">https://www.cnblogs.com/gne-hwz/p/10714013.html</a><br>安装：<a href="https://blog.csdn.net/almahehe/article/details/75390572">https://blog.csdn.net/almahehe/article/details/75390572</a><br>（建议看尚硅谷视频进行快速安装）<br>安装之后，可以访问 ip:15672 ，查看发送消息的端口（5672）和用户。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638169386681-e382c30c-baba-4fbb-bd40-aaa7b0a1eac6.png#clientId=uc4bbfa15-6ab6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=173&amp;id=u1a771f9c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=102&amp;originWidth=450&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=28980&amp;status=done&amp;style=none&amp;taskId=ua13bea1f-438b-4ef8-8913-b4ccb9fa78c&amp;title=&amp;width=761.9931030273438#averageHue=%23f1f1f1&amp;id=pNXMC&amp;originHeight=102&amp;originWidth=450&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="简单队列模式">简单队列模式</h2><h3 id="生产者代码">生产者代码</h3><ol><li>项目依赖：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定jdk编译版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--rabbitmq依赖客户端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--操作文件流的依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>生产者代码：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">japackage com.atguigu.rabbitmq.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/11/28 22:15</span></span><br><span class="line"><span class="comment"> * 生产者 ：发消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置工厂ip  连接rabbitmq的队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;59.110.171.189&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 参数；1.队列名称</span></span><br><span class="line"><span class="comment">         *      2.队列里面的消息是否持久化（磁盘），默认消息存储在内存中（不持久化false）</span></span><br><span class="line"><span class="comment">         *      3.该队列是否只供一个消费者进行消费，是否消息独有，true只允许一个消费者进行消费，默认是false（可以多个消费者消费）</span></span><br><span class="line"><span class="comment">                4. 是否自动删除，最后一个消费者断开连接后，该队列是否自动删除，true自动删除，false不自动删除</span></span><br><span class="line"><span class="comment">                5.其他参数（延迟消息......）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//发消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消息</span></span><br><span class="line"><span class="comment">         * 1. 发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * 2. 路由的key值是哪个，本次是队列的名称</span></span><br><span class="line"><span class="comment">         * 3. 其他参数信息</span></span><br><span class="line"><span class="comment">         * 4. 发送消息的消息体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行报超时错误，需要打开云服务器的安全组 5672 端口。<br>（参考博客：<a href="https://www.cnblogs.com/jxearlier/p/11920825.html">https://www.cnblogs.com/jxearlier/p/11920825.html</a>）</p><h3 id="消费者代码">消费者代码</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">package com.atguigu.rabbitmq.one;</span><br><span class="line"></span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author LiFang</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @since 2021/11/29 15:04</span><br><span class="line"> * 消费者:接收消息</span><br><span class="line"> */</span><br><span class="line">public class Consumer &#123;</span><br><span class="line">    //队列名称</span><br><span class="line">    public static final String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    //接收消息</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost(&quot;59.110.171.189&quot;);</span><br><span class="line">        factory.setUsername(&quot;admin&quot;);</span><br><span class="line">        factory.setPassword(&quot;123&quot;);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明 接收消息</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;;</span><br><span class="line">        //取消消息时的回调</span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;消息消费被中断&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        /**</span><br><span class="line">         * 消费者 消费消息</span><br><span class="line">         * 1.消费哪个队列</span><br><span class="line">         * 2. 消费成功之后是否要自动应答，true代表自动应答,false代表手动应答。</span><br><span class="line">         * 3. 消费者未成功消费的回调。</span><br><span class="line">         * 4. 消费者取消消费的回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638172828992-073b0df6-a480-4260-a724-e17e9191a44c.png#clientId=uc4bbfa15-6ab6-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=20&amp;id=u3ee077b2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=20&amp;originWidth=296&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2932&amp;status=done&amp;style=none&amp;taskId=ud645c173-0157-49f2-89fb-5d58c2cd89a&amp;title=&amp;width=296#averageHue=%232f3e49&amp;id=kWU4Y&amp;originHeight=20&amp;originWidth=296&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="测试生产者和消费者代码：">测试生产者和消费者代码：</h3><ol><li>先运行消费者代码，发现没有消息，再运行生产者代码，发送消息，再看消费者代码控制台，此时已经接收到消息。</li></ol><h2 id="工作队列模式">工作队列模式</h2><h3 id="轮训分发消息">轮训分发消息</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638191830547-a43bbaa1-a524-4603-b6a9-0824e943cf9c.png#clientId=u43ded51d-0244-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=546&amp;id=ucf96c5e0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=546&amp;originWidth=1278&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=220503&amp;status=done&amp;style=none&amp;taskId=ub030755f-49df-4184-9d0d-65bfa0e561e&amp;title=&amp;width=1278#averageHue=%23f7f7f7&amp;id=kyxCV&amp;originHeight=546&amp;originWidth=1278&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ol><li>抽取连接工厂工具类：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">package com.atguigu.rabbitmq.utils;</span><br><span class="line"></span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author LiFang</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @since 2021/11/29 19:48</span><br><span class="line"> * 连接工厂创建信道的工具类</span><br><span class="line"> */</span><br><span class="line">public class RabbitMqUtils &#123;</span><br><span class="line">    public static Channel getChannel() throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost(&quot;59.110.171.189&quot;);</span><br><span class="line">        factory.setUsername(&quot;admin&quot;);</span><br><span class="line">        factory.setPassword(&quot;123&quot;);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        return channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>工作线程代码：（消费者）</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">package com.atguigu.rabbitmq.two;</span><br><span class="line"></span><br><span class="line">import com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line">import com.rabbitmq.client.CancelCallback;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.DeliverCallback;</span><br><span class="line">import com.rabbitmq.client.Delivery;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author LiFang</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @since 2021/11/29 19:55</span><br><span class="line"> * 这是一个工作线程（相当于之前的消费者）</span><br><span class="line"> */</span><br><span class="line">public class Worker01 &#123;</span><br><span class="line">    //队列名称</span><br><span class="line">    public static final String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    //接收消息 的工作线程</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        //消息的接收</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;接收到的消息：&quot; + new String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        //消息接收被取消时 执行</span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + &quot;消费者取消消费接口回调逻辑&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        /*</span><br><span class="line">         * 消费者 消费消息</span><br><span class="line">         * 1.消费哪个队列</span><br><span class="line">         * 2. 消费成功之后是否要自动应答，true代表自动应答,false代表手动应答。</span><br><span class="line">         * 3. 消费者未成功消费的回调。</span><br><span class="line">         * 4. 消费者取消消费的回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>启动两个工作线程（消费者）</li></ol><p>前提是在 idea 设置允许方法多个并行运行：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638188489814-b081e679-bc7f-4cad-964e-bfb80575820c.png#clientId=u43ded51d-0244-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=636&amp;id=uf61f07dc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=869&amp;originWidth=1143&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=94819&amp;status=done&amp;style=none&amp;taskId=u4472c929-c48f-4a7d-ab7d-ec2994b75e5&amp;title=&amp;width=836.9862060546875#averageHue=%233b4043&amp;id=zVInE&amp;originHeight=869&amp;originWidth=1143&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638188418807-97ce766a-47ef-458c-8413-d496cbcddbed.png#clientId=u43ded51d-0244-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=172&amp;id=u35f12aab&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=172&amp;originWidth=669&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=20804&amp;status=done&amp;style=none&amp;taskId=uf688cf36-6dc9-43f1-be3d-946b8a45d78&amp;title=&amp;width=669#averageHue=%232a373f&amp;id=yNG1N&amp;originHeight=172&amp;originWidth=669&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ol start="4"><li>生产者代码：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">package com.atguigu.rabbitmq.two;</span><br><span class="line"></span><br><span class="line">import com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author LiFang</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @since 2021/11/29 21:04</span><br><span class="line"> * 生产者 发送大量消息</span><br><span class="line"> */</span><br><span class="line">public class Task01 &#123;</span><br><span class="line">    public static final String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        /*</span><br><span class="line">         * 生成一个队列</span><br><span class="line">         * 参数；1.队列名称</span><br><span class="line">         *      2.队列里面的消息是否持久化（磁盘），默认消息存储在内存中（不持久化false）</span><br><span class="line">         *      3.该队列是否只供一个消费者进行消费，是否消息独有，true只允许一个消费者进行消费，默认是false（可以多个消费者消费）</span><br><span class="line">         4. 是否自动删除，最后一个消费者断开连接后，该队列是否自动删除，true自动删除，false不自动删除</span><br><span class="line">         5.其他参数（延迟消息......）</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">            System.out.println(&quot;发送消息完成：&quot; + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>测试：启动生产者</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638192109706-2649384b-8559-4d7e-8609-220f576c3e25.png#clientId=u43ded51d-0244-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=275&amp;id=u4261e57f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=275&amp;originWidth=591&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25224&amp;status=done&amp;style=none&amp;taskId=ue3dff20d-583f-4d0b-bb12-94ccae95bc1&amp;title=&amp;width=591#averageHue=%232c373d&amp;id=PuJou&amp;originHeight=275&amp;originWidth=591&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>可以看见消费者轮循接收消息：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638192164342-16d183be-bbe5-4de9-bac4-d87bd87a746b.png#clientId=u43ded51d-0244-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=179&amp;id=ue97a7cdb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=179&amp;originWidth=591&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=23018&amp;status=done&amp;style=none&amp;taskId=u7cff6d1a-b142-4d52-a1c5-1cca6fd241e&amp;title=&amp;width=591#averageHue=%232f3c44&amp;id=Upfv4&amp;originHeight=179&amp;originWidth=591&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638192176544-d380de90-ff7a-48a7-a080-c4a1ac193460.png#clientId=u43ded51d-0244-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=198&amp;id=ubb73d589&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=198&amp;originWidth=598&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=23978&amp;status=done&amp;style=none&amp;taskId=u3ac63e3a-6d82-4340-9fed-c68c8fbf564&amp;title=&amp;width=598#averageHue=%232f3b43&amp;id=xLv8Q&amp;originHeight=198&amp;originWidth=598&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="消息应答">消息应答</h2><h3 id="自动应答">自动应答</h3><p>不建议使用，仅适用在消费者可以高效并以某种速率能够处理这些消息的情况。</p><h3 id="手动应答">手动应答</h3><h4 id="消息应答的方法：">消息应答的方法：</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638193415623-6b7ff26f-8cc3-4abd-b1c6-41f79897f0cf.png#clientId=u43ded51d-0244-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=312&amp;id=ud16b0385&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=312&amp;originWidth=737&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=100867&amp;status=done&amp;style=none&amp;taskId=u39cf8244-b605-4c5d-baca-fe2103cd9d3&amp;title=&amp;width=737#averageHue=%23f5f5f5&amp;id=S2b1y&amp;originHeight=312&amp;originWidth=737&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h4 id="批量处理-Multiple">批量处理 Multiple</h4><p>手动应答的好处：可以批量应答，并减少网络拥堵。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638282925466-4d3081e6-809c-4a5f-9472-741dacb0cc7c.png#clientId=ub82069db-0272-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=588&amp;id=u97ebb457&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=811&amp;originWidth=1024&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=292383&amp;status=done&amp;style=none&amp;taskId=uf04a703e-97b1-4fe2-b58f-33d8b0dff4d&amp;title=&amp;width=741.9931030273438#averageHue=%23f6f5f5&amp;id=rUzZh&amp;originHeight=811&amp;originWidth=1024&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>但是批量应答可能会丢失消息。所以尽量不要批量应答，将 multiple 设置为 false。</p><h3 id="消息自动重新入队">消息自动重新入队</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638317239422-ab1bab41-ac6f-4a05-b3c5-c539d9e6dcd1.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=85&amp;id=u97c18f3b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=79&amp;originWidth=665&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=57746&amp;status=done&amp;style=none&amp;taskId=u14e494b5-3291-4daf-ada5-47aafa5eab0&amp;title=&amp;width=715.0000610351562#averageHue=%23ebeae9&amp;id=qAYOD&amp;originHeight=79&amp;originWidth=665&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638317701734-1133a417-ebbe-4ad9-8453-f0803583491a.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=308&amp;id=u7be19416&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=469&amp;originWidth=1088&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=306122&amp;status=done&amp;style=none&amp;taskId=u7d90ec89-bd9a-4090-bda5-c09c6014c27&amp;title=&amp;width=714.9862060546875#averageHue=%23e5e4df&amp;id=o9cFt&amp;originHeight=469&amp;originWidth=1088&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>测试：</p><ol><li>生产者：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">package com.atguigu.rabbitmq.three;</span><br><span class="line"></span><br><span class="line">import com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author LiFang</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @since 2021/12/1 14:46</span><br><span class="line"> * 消息在手动应答时不丢失,放回队列中重新消费</span><br><span class="line"> */</span><br><span class="line">public class Task2 &#123;</span><br><span class="line">    //队列名称</span><br><span class="line">    public static final String TASK_QUEUE_NAME = &quot;ack_queue&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        //声明队列</span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, false, false, false, null);</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(&quot;&quot;, TASK_QUEUE_NAME, null, message.getBytes());</span><br><span class="line">            System.out.println(&quot;生产者发出消息：&quot; + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>两个消费者（消息手动应答）：</li></ol><p>消费者一：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">package com.atguigu.rabbitmq.three;</span><br><span class="line"></span><br><span class="line">import com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line">import com.atguigu.rabbitmq.utils.SleepUtils;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author LiFang</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @since 2021/12/1 14:58</span><br><span class="line"> * 消息在手动应答时不丢失，放回队列中重新消费</span><br><span class="line"> */</span><br><span class="line">public class Work03 &#123;</span><br><span class="line">    //队列名称</span><br><span class="line">    public static final String TASK_QUEUE_NAME = &quot;ack_queue&quot;;</span><br><span class="line"></span><br><span class="line">    //接收消息</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(&quot;C1等待接收消息处理时间较短&quot;);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            //沉睡1s</span><br><span class="line">            SleepUtils.sleep(1);</span><br><span class="line">            System.out.println(&quot;接收到的消息：&quot; + new String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">            //手动应答（通过信道）</span><br><span class="line">            /*参数：</span><br><span class="line">            1. 消息的标记 tag</span><br><span class="line">            2. 是否批量应答  false:不批量应答信道中的消息，true:批量</span><br><span class="line">             */</span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;;</span><br><span class="line">        //采用手动应答</span><br><span class="line">        boolean autoAck = false;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + &quot;消费者取消消费接口的回调逻辑&quot;);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者二：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">package com.atguigu.rabbitmq.three;</span><br><span class="line"></span><br><span class="line">import com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line">import com.atguigu.rabbitmq.utils.SleepUtils;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author LiFang</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @since 2021/12/1 14:58</span><br><span class="line"> * 消息在手动应答时不丢失，放回队列中重新消费</span><br><span class="line"> */</span><br><span class="line">public class Work04 &#123;</span><br><span class="line">    //队列名称</span><br><span class="line">    public static final String TASK_QUEUE_NAME = &quot;ack_queue&quot;;</span><br><span class="line"></span><br><span class="line">    //接收消息</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(&quot;C2等待接收消息处理时间较短&quot;);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            //沉睡1s</span><br><span class="line">            SleepUtils.sleep(30);</span><br><span class="line">            System.out.println(&quot;接收到的消息：&quot; + new String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">            //手动应答（通过信道）</span><br><span class="line">            /*参数：</span><br><span class="line">            1. 消息的标记 tag</span><br><span class="line">            2. 是否批量应答  false:不批量应答信道中的消息，true:批量</span><br><span class="line">             */</span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        &#125;;</span><br><span class="line">        //采用手动应答</span><br><span class="line">        boolean autoAck = false;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + &quot;消费者取消消费接口的回调逻辑&quot;);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试步骤：<br>① 先启动 task2，创建 ack_queue 队列；（在 ip:15672 的 queue 列表中可以看到目前拥有的队列）<br>② 启动 work02，work03 接收消息（消费者）；<br>③ 发消息：在 task2 控制台输入 aa,bb,cc,dd,ee,ff，可以看到 work2 和 work3 是轮训接收消息；如果到 work03 应该接收消息 ee 时，work03 突然挂掉，此时 ee 会被转发给 work02 中的 C1，这时 C1 会接收到 ee，因此消息不会丢失，这说明了 rabbitmq 有手动应答的能力，只要没有收到消息，就不会手动应答，从而将消息放回队列。而队列又再次将消息传递给 C1 进行重新消费，从而导致 ee 并没有丢失。<img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638348662336-051f5011-f512-44d1-bb05-053e49ba050c.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=499&amp;id=u60c5aa9e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=499&amp;originWidth=1092&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=254728&amp;status=done&amp;style=none&amp;taskId=u6c03afcd-9d58-4d4b-b839-5e4801e20e0&amp;title=&amp;width=1092#averageHue=%23f5f5f5&amp;id=Rq0q6&amp;originHeight=499&amp;originWidth=1092&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="队列持久化">队列持久化</h2><p>如果存在同名未被持久化的队列，则需要先删除原先的未被持久化的队列，再重新生成一个持久化队列。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明队列</span></span><br><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>; <span class="comment">//在生产者中，需要让queue进行持久化</span></span><br><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>生成一个持久化队列之后，在 rabbitmq 控制台中这个队列的 features 属性会出现 D（代表持久化）。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638359722330-59d15b49-1b8d-4d93-85aa-ecd40227bd45.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=129&amp;id=ufd6f763b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=129&amp;originWidth=781&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13881&amp;status=done&amp;style=none&amp;taskId=uab54d6ef-4036-4edf-bca6-ba4a9dcac1d&amp;title=&amp;width=781#averageHue=%23f3f1f0&amp;id=iMXeX&amp;originHeight=129&amp;originWidth=781&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="消息持久化">消息持久化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置生产者发送消息为持久化消息（要求保存到磁盘上MessageProperties.PERSISTENT_TEXT_PLAIN）</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br></pre></td></tr></table></figure><h2 id="不公平分发">不公平分发</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在消费者中接收消息之前设置不公平分发</span></span><br><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638361240814-a1349c7f-2e3e-410a-ba3b-f2f872fab0bb.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=232&amp;id=u1ff04a34&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=232&amp;originWidth=385&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=20173&amp;status=done&amp;style=none&amp;taskId=ub1b60899-802e-4d67-9aed-a99c48b5db3&amp;title=&amp;width=385#averageHue=%23303d45&amp;id=vTMLG&amp;originHeight=232&amp;originWidth=385&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638361251165-68b13d22-fe49-4fd8-9471-26161051c180.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=177&amp;id=u477bebf6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=177&amp;originWidth=431&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18613&amp;status=done&amp;style=none&amp;taskId=ue60522ee-50ed-46f9-ae69-472369ce4b6&amp;title=&amp;width=431#averageHue=%232c3a42&amp;id=zGQk4&amp;originHeight=177&amp;originWidth=431&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="预取值">预取值</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638361857297-fa168e46-191d-44b2-8ce2-df2cb52a382d.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=282&amp;id=ue1e2c233&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=453&amp;originWidth=1130&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=347909&amp;status=done&amp;style=none&amp;taskId=ue241edd5-d375-46cb-9668-4a4eb4d7c9c&amp;title=&amp;width=703.0000610351562#averageHue=%23e4e4e5&amp;id=mwjn3&amp;originHeight=453&amp;originWidth=1130&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">5</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><h2 id="发布确认原理">发布确认原理</h2><h2 id="image-png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638364988019-b29d7c44-ebca-4978-95fd-034500d1bd7b.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=369&amp;id=u98ff6bb0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=369&amp;originWidth=930&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=222643&amp;status=done&amp;style=none&amp;taskId=ua25c2547-8233-4893-8d5b-4406b84e85f&amp;title=&amp;width=930#averageHue=%23fafafb&amp;id=Xek0V&amp;originHeight=369&amp;originWidth=930&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></h2><p>在信道之后开启发布确认：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//信道开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure><h2 id="单个发布确认">单个发布确认</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638365489548-64267da5-f60d-4b88-98af-bdf5806d5038.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=203&amp;id=ub1148f56&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=203&amp;originWidth=993&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=342872&amp;status=done&amp;style=none&amp;taskId=u2df32a3e-4c69-4599-868a-d81e33495ec&amp;title=&amp;width=993#averageHue=%23d0dcda&amp;id=qVQAu&amp;originHeight=203&amp;originWidth=993&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.four;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/1 21:32</span></span><br><span class="line"><span class="comment"> * 发布确认模式：</span></span><br><span class="line"><span class="comment"> * 使用的时间  比较哪种确认方式是最好的</span></span><br><span class="line"><span class="comment"> * 1.单个确认</span></span><br><span class="line"><span class="comment"> * 2.批量确认</span></span><br><span class="line"><span class="comment"> * 3.异步批量确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfireMessage</span> </span>&#123;</span><br><span class="line">    <span class="comment">//批量发消息的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_COUNT = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 单个确认</span></span><br><span class="line">        ConfireMessage.publicMessageIndividually(); <span class="comment">//发布1000个单独确认消息，耗时29726ms</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单个确认</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publicMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//用信道声明队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量发消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String massage = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, massage.getBytes());</span><br><span class="line">            <span class="comment">//单个消息就马上进行发布确认</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span>+MESSAGE_COUNT+<span class="string">&quot;个单独确认消息，耗时&quot;</span>+(end - begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批量发布确认">批量发布确认</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638366964213-10397181-357d-4896-9e91-84690b69c982.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=137&amp;id=ude627a73&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=137&amp;originWidth=968&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=206130&amp;status=done&amp;style=none&amp;taskId=u0c3dafe3-1f66-4cc1-83ba-f5e8edae8b3&amp;title=&amp;width=968#averageHue=%23d7d9d8&amp;id=tMsLz&amp;originHeight=137&amp;originWidth=968&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量发布确认</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publicMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//用信道声明队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量确认消息大小</span></span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//批量发布消息， 批量发布确认</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">//发布确认</span></span><br><span class="line">            <span class="keyword">if</span> (i % batchSize == <span class="number">0</span>) &#123;</span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息，耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="异步发布确认">异步发布确认</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638368249755-46e1c3b8-f891-48b0-a77b-21b9a80f4e5e.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=119&amp;id=u5fcd19f7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=119&amp;originWidth=1189&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=231115&amp;status=done&amp;style=none&amp;taskId=u473c99f9-e088-4ad3-84e3-82e606c7d63&amp;title=&amp;width=1189#averageHue=%23e2dfd4&amp;id=Jwh7I&amp;originHeight=119&amp;originWidth=1189&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638368124379-5cdb8cbd-707a-4a1f-92f4-3dc511a9ec11.png#clientId=u446e2507-b64d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=571&amp;id=u4b5d988b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=441&amp;originWidth=964&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=239080&amp;status=done&amp;style=none&amp;taskId=ua0b85de0-7119-4e3a-a0be-75854b9aaac&amp;title=&amp;width=1248.9931030273438#averageHue=%23f7f7f7&amp;id=T1TVR&amp;originHeight=441&amp;originWidth=964&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量发消息的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_COUNT = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 单个确认</span></span><br><span class="line"><span class="comment">//        ConfireMessage.publicMessageIndividually(); //发布1000个单独确认消息，耗时29726ms</span></span><br><span class="line"><span class="comment">//        2. 批量确认</span></span><br><span class="line"><span class="comment">//        ConfireMessage.publicMessageBatch();  //发布1000个批量确认消息，耗时761ms（弊端：无法确认哪个消息未被确认）</span></span><br><span class="line"><span class="comment">//        3. 异步确认</span></span><br><span class="line">        ConfireMessage.publicMessageAsync(); <span class="comment">//发布1000个异步确认消息，耗时181ms</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//异步发布确认</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publicMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//用信道声明队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//消息确认成功，回调函数</span></span><br><span class="line">        ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息确认失败，回调函数</span></span><br><span class="line">        ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//准备消息的监听器，监听哪些消息成功了，哪些消息失败了</span></span><br><span class="line">        channel.addConfirmListener(ackCallback, nackCallback);  <span class="comment">//异步通知</span></span><br><span class="line">        <span class="comment">//异步发布确认</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String massage = <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, massage.getBytes());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步确认消息，耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="如何处理异步未确认消息">如何处理异步未确认消息</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638404469016-06a08296-9aa6-4d65-8d1c-4c70fb4cd5b8.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=97&amp;id=u0927e367&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=97&amp;originWidth=1033&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=122865&amp;status=done&amp;style=none&amp;taskId=u67d3a3c6-2f1a-4be9-9c0c-f7d2e743935&amp;title=&amp;width=1033#averageHue=%23dcd8cd&amp;id=frSPr&amp;originHeight=97&amp;originWidth=1033&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>上述异步确认有两个线程：</p><ul><li>发消息的线程</li><li>监听器的线程</li></ul><p>两个线程之间交互，只能用<strong>并发链路式队列（可以在确认发布与发布线程之间进行消息传递）</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步发布确认</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publicMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//用信道声明队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        线程安全有序的哈希表，适用于高并发的情况</span></span><br><span class="line"><span class="comment">        1. 轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">        2. 轻松批量删除条目，只要给序号</span></span><br><span class="line"><span class="comment">        3.支持高并发(多线程)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long,String&gt; outstandingConfirms = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息确认成功，回调函数</span></span><br><span class="line">        ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">            <span class="comment">//2. 删除已经确认的消息   剩下的就是未确认的消息</span></span><br><span class="line">            <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                <span class="comment">//如果是批量确认，就去批量删除</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long,String&gt; confirmed = outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果是单个确认，就去单个删除</span></span><br><span class="line">                outstandingConfirms.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息确认失败，回调函数</span></span><br><span class="line">        ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">            <span class="comment">//3. 打印未确认的消息有哪些</span></span><br><span class="line">            String message = outstandingConfirms.get(deliveryTag);</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息是：&quot;</span>+message+<span class="string">&quot;:::::未确认的消息tag:&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//准备消息的监听器，监听哪些消息成功了，哪些消息失败了</span></span><br><span class="line">        channel.addConfirmListener(ackCallback, nackCallback);  <span class="comment">//异步通知</span></span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">            <span class="comment">// 1. 此处记录下所有要发送的消息  消息的总和(每发一次消息就记录一次)</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(),message);</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步确认消息，耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上三种发布确认速度对比：</p></blockquote><ul><li>单独发布消息：同步等待确认，简单，但吞吐量非常有限。</li><li>批量发布消息：批量同步等待确认，简单，合理的吞吐量，一旦出现问题，很难推断出是哪条出现了问题</li><li>异步处理：最佳性能和资源利用，在出现错误的情况下，可以很好的控制，但是实现起来稍微难些。</li></ul><h2 id="交换机">交换机</h2><h3 id="交换机的作用">交换机的作用</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638406810806-e429e00e-78d1-42e2-ab92-c3a53f8c2fa9.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=270&amp;id=uc3415ba1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=387&amp;originWidth=1291&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=191628&amp;status=done&amp;style=none&amp;taskId=uee2f50b0-7b80-4d38-9c1b-25806445f5f&amp;title=&amp;width=900.9896240234375#averageHue=%23f5f4f4&amp;id=tFgNi&amp;originHeight=387&amp;originWidth=1291&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="交换机的类型">交换机的类型</h3><ul><li>直接（direct）== 路由类型</li><li>主题（topic）</li><li>标题（headers）（企业不常用）</li><li>扇出（fanout）== 发布订阅类型</li><li>无名类型（默认类型），通常用空串进行识别</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638407294007-f1bd9624-be98-4b90-ba72-9c29d88c326d.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=76&amp;id=u21ac6756&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=76&amp;originWidth=987&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=103665&amp;status=done&amp;style=none&amp;taskId=u47150f74-3b3b-4cc4-befe-f25d9650214&amp;title=&amp;width=987#averageHue=%23cbc7bb&amp;id=KlfHY&amp;originHeight=76&amp;originWidth=987&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="临时队列">临时队列</h3><p>不带有持久化，一旦断开消费者的连接，队列将被自动删除。</p><p>创建临时队列：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638407906977-786b78e8-bfba-4cab-9aee-9ac7ec38a884.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=278&amp;id=u31ce7deb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=410&amp;originWidth=1086&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=55531&amp;status=done&amp;style=none&amp;taskId=ub3aa0ca4-c823-418b-b8c7-0b7fbd67333&amp;title=&amp;width=736.9896240234375#averageHue=%23f4f2f1&amp;id=T0K86&amp;originHeight=410&amp;originWidth=1086&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="绑定">绑定</h3><p>就是交换机与队列之间的捆绑关系。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638408143523-d4c904d9-33e5-46bd-ad67-885e78b4c34b.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=637&amp;id=u8140e36d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=637&amp;originWidth=487&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26522&amp;status=done&amp;style=none&amp;taskId=ua5ea4c46-36c5-4183-aefe-f6a3f676385&amp;title=&amp;width=487#averageHue=%23faf5f5&amp;id=fwITJ&amp;originHeight=637&amp;originWidth=487&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="发布订阅模式（扇出模式-fanout）">发布订阅模式（扇出模式 fanout）</h3><p>类似广播，两个 routingkey 相同<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638408427104-577b627a-521a-4d94-89be-5bf0102440ea.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=218&amp;id=u3ae99c2f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=292&amp;originWidth=1200&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=205919&amp;status=done&amp;style=none&amp;taskId=ufe252eb8-02f2-410e-8b74-b8d091c0d4a&amp;title=&amp;width=894#averageHue=%23f8ebea&amp;id=PeGnm&amp;originHeight=292&amp;originWidth=1200&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ol><li>生产者</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.five;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 9:59</span></span><br><span class="line"><span class="comment"> * 发消息：交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>两个消费者</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.five;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 9:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//声明一个队列  临时队列 (生成一个临时队列，队列的名称是随机的，当消费者断开与队列的连接的时候，队列就自动删除)</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//绑定交换机与队列</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息，把接收的消息打印在屏幕上。。。。&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogs01控制台接收到消息：&quot;</span> + <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>,  deliverCallback,consumerTag-&gt;&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.five;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 9:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs02</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//声明一个队列  临时队列 (生成一个临时队列，队列的名称是随机的，当消费者断开与队列的连接的时候，队列就自动删除)</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//绑定交换机与队列</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息，把接收的消息打印在屏幕上。。。。&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogs02控制台接收到消息：&quot;</span> + <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>,  deliverCallback,consumerTag-&gt;&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638410904168-80b297c1-26ef-4ee4-815c-065abea79bd2.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=328&amp;id=u29891926&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=328&amp;originWidth=580&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=28269&amp;status=done&amp;style=none&amp;taskId=u6700fa8b-9b2f-4717-91cf-0dfb20b528b&amp;title=&amp;width=580#averageHue=%232c383f&amp;id=Jf7Cl&amp;originHeight=328&amp;originWidth=580&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638410913426-c4d1faa3-7b8b-478c-ba35-665d73e98e8b.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=248&amp;id=ua55ed718&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=248&amp;originWidth=528&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=34020&amp;status=done&amp;style=none&amp;taskId=u415b65a3-7d21-4e16-a1a0-a15d7f3c4ca&amp;title=&amp;width=528#averageHue=%23323e46&amp;id=HNmyl&amp;originHeight=248&amp;originWidth=528&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638410920504-2f4c6248-02a0-4765-8647-4c8ab63551e1.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=255&amp;id=u9c537a4f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=255&amp;originWidth=517&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35282&amp;status=done&amp;style=none&amp;taskId=u97bfb701-f8bd-45ca-ac41-6f8259d9775&amp;title=&amp;width=517#averageHue=%23323e46&amp;id=BBNfG&amp;originHeight=255&amp;originWidth=517&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="直接交换机（路由模式-direct）">直接交换机（路由模式 direct）</h3><p>两个 routingkey 不相同<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638411099834-bf80fb1d-473a-4a01-8553-e47ee2cd3670.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=303&amp;id=ueba6aa41&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=303&amp;originWidth=874&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=98369&amp;status=done&amp;style=none&amp;taskId=u2145da18-8429-4959-ab30-43bcc28bb61&amp;title=&amp;width=874#averageHue=%23f6e6e4&amp;id=t5eGH&amp;originHeight=303&amp;originWidth=874&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>可以多重绑定。<br><strong>生产者发消息给队列，直接交换机通过不同 routingkey 路由到相应的队列，然后消费者接收指定日志。</strong></p><ol><li>发消息</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.six;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 9:59</span></span><br><span class="line"><span class="comment"> * 发消息：交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectLogs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>, <span class="keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>接收消息</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.six;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 10:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;console&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogs01控制台接收到消息：&quot;</span> + <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;console&quot;</span>, <span class="keyword">true</span>,  deliverCallback,consumerTag-&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.six;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 10:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;disk&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;disk&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogs02控制台接收到消息：&quot;</span> + <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;disk&quot;</span>, <span class="keyword">true</span>,  deliverCallback,consumerTag-&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638413931242-2c3ef4c2-f3e6-4e6e-ba39-5437dad24d40.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=182&amp;id=u9de2b784&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=182&amp;originWidth=630&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=21691&amp;status=done&amp;style=none&amp;taskId=u7cd93b89-df35-4f94-aa33-6626b0dc70b&amp;title=&amp;width=630#averageHue=%232c3941&amp;id=eyPPs&amp;originHeight=182&amp;originWidth=630&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638413948375-568b73ae-0203-4f53-9a9b-528667192aa2.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=182&amp;id=uc8400be0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=182&amp;originWidth=683&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=24900&amp;status=done&amp;style=none&amp;taskId=u38d71d59-3dd8-4324-9fae-335fd043524&amp;title=&amp;width=683#averageHue=%232e3b43&amp;id=U0kJT&amp;originHeight=182&amp;originWidth=683&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="主题交换机（Topic）">主题交换机（Topic）</h3><p>规范：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638414479059-98f3dc8e-ee99-4093-b2cb-81eaecec9acb.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=u34e92b6a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=226&amp;originWidth=834&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=170475&amp;status=done&amp;style=none&amp;taskId=ue217ff8b-9da9-493e-9a4b-07c6ab22bab&amp;title=&amp;width=834#averageHue=%23cfcac1&amp;id=KCIOt&amp;originHeight=226&amp;originWidth=834&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638415621949-8c1e4089-881d-482e-a377-ab7f224a2c92.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=257&amp;id=u76cf3ab8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=257&amp;originWidth=801&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=151366&amp;status=done&amp;style=none&amp;taskId=u98d7748e-2fc6-4df3-a740-cae3ba06db9&amp;title=&amp;width=801#averageHue=%23e6a198&amp;id=HeQJL&amp;originHeight=257&amp;originWidth=801&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638415680787-e95ef7a6-bec4-44b3-8e45-1e0c4adac6f7.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=350&amp;id=u280d2c9d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=350&amp;originWidth=829&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=181864&amp;status=done&amp;style=none&amp;taskId=u67807a72-c793-4b0b-a14e-e6270164016&amp;title=&amp;width=829#averageHue=%23e08176&amp;id=ZuvJl&amp;originHeight=350&amp;originWidth=829&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638415855921-8e2750b0-e5df-4b1c-90a3-7e3f696543d6.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=188&amp;id=uf97e55b4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=188&amp;originWidth=920&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=178229&amp;status=done&amp;style=none&amp;taskId=ufb1118a1-0b9d-4a97-bd09-0ff626585f5&amp;title=&amp;width=920#averageHue=%23c2beb2&amp;id=iZC7I&amp;originHeight=188&amp;originWidth=920&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="主题交换机（实战）">主题交换机（实战）</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638416303199-5f9e655c-c5c2-4a16-9d12-ba873c31c8e6.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=331&amp;id=u07108cc7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=331&amp;originWidth=1114&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=231103&amp;status=done&amp;style=none&amp;taskId=ud57ef875-e371-4fa6-980a-20a29a7366e&amp;title=&amp;width=1114#averageHue=%23f4eae8&amp;id=zgYBJ&amp;originHeight=331&amp;originWidth=1114&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ol><li>消费者</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.seven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 11:37</span></span><br><span class="line"><span class="comment"> * 声明主题交换机  及相关队列</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 消费者 C2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//交换机绑定 routingkey</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。。&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收队列：&quot;</span> + queueName + <span class="string">&quot;绑定键：&quot;</span> + message.getEnvelope().getRoutingKey());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.seven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 11:37</span></span><br><span class="line"><span class="comment"> * 声明主题交换机  及相关队列</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 消费者 C2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic02</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//交换机绑定 routingkey</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。。&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收队列：&quot;</span> + queueName + <span class="string">&quot;绑定键：&quot;</span> + message.getEnvelope().getRoutingKey());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>生产者</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.seven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.ECField;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 14:45</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogTopic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下图绑定关系如下：</span></span><br><span class="line"><span class="comment">         * Q1--&gt; 绑定的是： 中间带3个单词的字符串（*.orange*）</span></span><br><span class="line"><span class="comment">         * Q2--&gt; 绑定的是： 最后一个单词是rabbit的3个单词（*.*.rabbit）</span></span><br><span class="line"><span class="comment">         *                第一个单词是lazy的多个单词（lazy.#）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="string">&quot;被队列Q1Q2接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>, <span class="string">&quot;被队列Q1Q2接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>, <span class="string">&quot;被队列Q1接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>, <span class="string">&quot;被队列Q2接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>, <span class="string">&quot;虽然满足两个绑定但只被队列Q2接收一次&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>, <span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词不匹配任何绑定定会丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词但匹配Q2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">            String routingKey = bindingKeyEntry.getKey();</span><br><span class="line">            String message = bindingKeyEntry.getValue();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动消费者，再启动生产者。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638430253833-e55a9ffe-37a0-4c04-b7b7-093a65480f71.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=540&amp;id=u94f62b22&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=540&amp;originWidth=683&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=63817&amp;status=done&amp;style=none&amp;taskId=u846aee7e-23e7-429c-8c68-098657667fa&amp;title=&amp;width=683#averageHue=%232e3a41&amp;id=r1tul&amp;originHeight=540&amp;originWidth=683&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638430292235-0a8fd8ca-fdd9-4f2e-9a52-de2398da4db4.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=548&amp;id=u5b1d2810&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=548&amp;originWidth=649&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=60902&amp;status=done&amp;style=none&amp;taskId=uf769df3d-232c-4803-866e-9b789b65799&amp;title=&amp;width=649#averageHue=%23303b42&amp;id=p0vbD&amp;originHeight=548&amp;originWidth=649&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638430299720-f401248d-7efc-425f-aff1-59f8cda3349d.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=257&amp;id=u7c6af404&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=257&amp;originWidth=674&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33728&amp;status=done&amp;style=none&amp;taskId=u0e4568aa-d243-4696-a1eb-02eebf586cf&amp;title=&amp;width=674#averageHue=%23313d44&amp;id=Axrk6&amp;originHeight=257&amp;originWidth=674&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="死信队列">死信队列</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638430356782-4196f6b8-209f-489a-a5e5-e61974e711ef.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=299&amp;id=ud95905f1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=299&amp;originWidth=1069&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=430772&amp;status=done&amp;style=none&amp;taskId=ue469e4ea-c3e9-44f2-a5e6-4ac2443deba&amp;title=&amp;width=1069#averageHue=%23dad7cf&amp;id=ZL2Da&amp;originHeight=299&amp;originWidth=1069&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638430504276-84f3e02c-d80f-4fe9-9b9a-b8d9ac3b8290.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=298&amp;id=u8670c10d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=298&amp;originWidth=643&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=162345&amp;status=done&amp;style=none&amp;taskId=ue72cf50e-a8d2-4f86-8a8f-e35ebf10e89&amp;title=&amp;width=643#averageHue=%23ddd6c3&amp;id=rBdXQ&amp;originHeight=298&amp;originWidth=643&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638430601814-eb3112b8-d77b-4213-ad2c-df3c394a36b7.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=553&amp;id=ufda1712c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=553&amp;originWidth=1136&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=162361&amp;status=done&amp;style=none&amp;taskId=u55e88e2a-dc14-44b5-9eb9-8663773f317&amp;title=&amp;width=1136#averageHue=%23fbfafa&amp;id=pQqf7&amp;originHeight=553&amp;originWidth=1136&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ul><li>消费者 1：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.eight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 15:40</span></span><br><span class="line"><span class="comment"> * 死信队列</span></span><br><span class="line"><span class="comment"> * 消费者1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//普通交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//普通队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE = <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//死信队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE = <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明死信和普通交换机， 类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明普通队列</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//过期时间</span></span><br><span class="line"><span class="comment">//        arguments.put(&quot;x-message-ttl&quot;,10000);</span></span><br><span class="line">        <span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//设置正常队列的长度的限制</span></span><br><span class="line"><span class="comment">//        arguments.put(&quot;x-max-length&quot;, 19);</span></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">        <span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//交换机与队列绑定</span></span><br><span class="line">        <span class="comment">//绑定普通交换机与普通队列</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//绑定死信交换机与死信队列</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.........&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            <span class="keyword">if</span> (msg.equals(<span class="string">&quot;info5&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;此消息被C1拒绝的&quot;</span> + msg);</span><br><span class="line">                <span class="comment">//拒绝此消息，并且不放回队列中。因此成为死信</span></span><br><span class="line">                channel.basicReject(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01接收的消息&quot;</span> + msg);</span><br><span class="line">                <span class="comment">//不批量应答</span></span><br><span class="line">                channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//开启手动应答（如果不开启手动应答，就不存在拒绝了）</span></span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE, <span class="keyword">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消费者 2：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.eight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 15:40</span></span><br><span class="line"><span class="comment"> * 死信队列</span></span><br><span class="line"><span class="comment"> * 消费者2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer02</span> </span>&#123;</span><br><span class="line">    <span class="comment">//死信队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE = <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.........&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer02接收的消息&quot;</span> + <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(DEAD_QUEUE, <span class="keyword">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.eight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 16:13</span></span><br><span class="line"><span class="comment"> * 死信队列-生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//普通交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//死信时间  设置ttl时间</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试步骤：</p><ol><li>运行消费者：会发现普通和死信交换机已经绑定各自的队列。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638445377947-e4a087d0-b755-4178-aa6d-7ae082107bb0.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=495&amp;id=ud91030e8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=495&amp;originWidth=541&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=23775&amp;status=done&amp;style=none&amp;taskId=u8f85c23d-a811-41b4-a478-a20609fc50a&amp;title=&amp;width=541#averageHue=%23f8f7f6&amp;id=xwjE9&amp;originHeight=495&amp;originWidth=541&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638445475857-ba40932b-588f-43d3-b3a6-5f2660bcd241.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=498&amp;id=ub28b2410&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=498&amp;originWidth=601&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25129&amp;status=done&amp;style=none&amp;taskId=u8de3a461-08ce-49b9-9936-e0cf7fa1363&amp;title=&amp;width=601#averageHue=%23f8f7f7&amp;id=Jcymv&amp;originHeight=498&amp;originWidth=601&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ol start="2"><li>测试<strong>队列达到最大长度</strong>，关闭消费者 1 和 2，开启生产者：消息会积压在队列中，消费者 1 所在的普通队列消息限制有 6 条，剩下的 4 条会进入消费者 2 所在的死信队列。如下图所示：</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638448087379-8c4e5c46-39ca-49fd-8024-4111b0a5d431.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=571&amp;id=u9eb9c88a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=571&amp;originWidth=1083&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=79389&amp;status=done&amp;style=none&amp;taskId=ua5f78b60-fd26-4cb8-9cf8-f0e0f17270b&amp;title=&amp;width=1083#averageHue=%23f1eeed&amp;id=s5bzi&amp;originHeight=571&amp;originWidth=1083&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ol start="3"><li>取消普通队列的最大长度限制，测试<strong>消息 ttl 过期</strong>：关闭消费者 1 和 2，开启生产者发送消息。（消息会因为没人接收，会在 ttl 时间内积压在普通队列中， ttl 过期后，消息会进入死信队列中。）</li></ol><p>生产者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.eight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 16:13</span></span><br><span class="line"><span class="comment"> * 死信队列-生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//普通交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//死信时间  设置ttl时间</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>测试<strong>消息被拒</strong>：</li></ol><p>开启消费者 1 和 2，再开启生产者。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638450659287-e191b69a-07c6-4d5e-8f54-05d22263a235.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=274&amp;id=u03d42d3b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=274&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32103&amp;status=done&amp;style=none&amp;taskId=uf69d66f1-feae-4ff6-83ca-af7f8a83127&amp;title=&amp;width=642#averageHue=%232e3b43&amp;id=jR4qW&amp;originHeight=274&amp;originWidth=642&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638450668535-06aa1842-3563-455e-bb20-6376694fae1f.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=202&amp;id=u33f7f3ac&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=202&amp;originWidth=616&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=23460&amp;status=done&amp;style=none&amp;taskId=ua7a303f7-25d6-4fc0-8d46-d522a51ded6&amp;title=&amp;width=616#averageHue=%232d3a42&amp;id=vAYSS&amp;originHeight=202&amp;originWidth=616&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="延迟队列（基于死信队列）">延迟队列（基于死信队列）</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638450862631-363c8d24-6a72-463a-b827-201e6f79cb79.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=128&amp;id=u8aa7212b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=128&amp;originWidth=1081&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=190603&amp;status=done&amp;style=none&amp;taskId=ue97c71c8-4947-4c82-be00-e98e36ba920&amp;title=&amp;width=1081#averageHue=%23e1dfd3&amp;id=xrjpE&amp;originHeight=128&amp;originWidth=1081&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638451047144-5f4983f1-3a0e-472b-95f3-26635a911749.png#clientId=u268c19fe-902d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=399&amp;id=ud5620b6f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=399&amp;originWidth=869&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=265988&amp;status=done&amp;style=none&amp;taskId=ub1f53a1e-1377-4e43-ab1d-13e29cf4118&amp;title=&amp;width=869#averageHue=%23f3f3f2&amp;id=O4W2R&amp;originHeight=399&amp;originWidth=869&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="整合-SpringBoot">整合 SpringBoot</h3><h4 id="实现延迟队列：">实现延迟队列：</h4><ol><li>依赖：</li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.atguigu.rabbitmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot-rabbitmq&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;springboot-rabbitmq&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-amqp --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">        &lt;!--web服务器，可以自启动--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--快速进行json转换--&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.78&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.amqp/spring-rabbit-test --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.4.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.18.22&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>yml 配置文件：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: <span class="number">59.110</span><span class="number">.171</span><span class="number">.189</span></span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: admin</span><br><span class="line">    password: <span class="number">123</span></span><br></pre></td></tr></table></figure><ol start="3"><li>swagger 配置类：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/2 22:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;rabbitmq  接口文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot; 本文档描述了 rabbitmq  微服务接口定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;enjoy6288&quot;</span>, <span class="string">&quot;http://atguigu.com&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;1846015350@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638490298754-a2b1ced5-676b-4f68-86e0-31f05266088f.png#clientId=u7522214d-0203-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=215&amp;id=u8ba627f6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=215&amp;originWidth=1100&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=132048&amp;status=done&amp;style=none&amp;taskId=ud9c3f28a-b8df-44d1-b9df-dc90c70e046&amp;title=&amp;width=1100#averageHue=%23f9f8f6&amp;id=Iv7m8&amp;originHeight=215&amp;originWidth=1100&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ol start="4"><li>声明队列配置文件：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/3 8:15</span></span><br><span class="line"><span class="comment"> * TTL队列，  配置文件类代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TtlQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//普通交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_EXCHANGE = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="comment">//普通队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_A = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_B = <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="comment">//死信队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUE = <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明xExchange 别名</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">xExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">yExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明普通队列  ttl为10s</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信 routing-key</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置ttl  单位为ms</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明普通队列  ttl为40s</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信 routing-key</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置ttl  单位为ms</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DEAD_LETTER_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定交换机和队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueABindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA, <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB, <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueDBindingY</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD, <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>消费者：接收消息</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/3 9:01</span></span><br><span class="line"><span class="comment"> * 队列ttl 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，收到死信队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>发送消息：Controller</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/3 8:47</span></span><br><span class="line"><span class="comment"> * 发送延迟消息</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * http://localhost:8080/ttl/sendMsg/嘻嘻嘻</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始发消息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一条消息给两个ttl队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自ttl为10s的队列&quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自ttl为40s的队列&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:8080/ttl/sendMsg/">http://localhost:8080/ttl/sendMsg/</a>嘻嘻嘻<br>控制台打印结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638494307481-a59aaddb-4efb-4200-9e05-0e34602ded36.png#clientId=u7522214d-0203-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=202&amp;id=u66541ef9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=202&amp;originWidth=1365&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=62756&amp;status=done&amp;style=none&amp;taskId=ua128108f-eaa5-47fc-ab0d-e56fe3f57f4&amp;title=&amp;width=1365#averageHue=%23333e45&amp;id=tO8el&amp;originHeight=202&amp;originWidth=1365&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h4 id="延迟队列优化：">延迟队列优化：</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638494906968-c2a2e16a-a5b3-4c44-83bc-5846e35977d0.png#clientId=u7522214d-0203-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=333&amp;id=u5def25ea&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=333&amp;originWidth=1070&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=169463&amp;status=done&amp;style=none&amp;taskId=uede9888d-c22a-46c9-a810-c9c1899d23a&amp;title=&amp;width=1070#averageHue=%23faf9f8&amp;id=PCbH9&amp;originHeight=333&amp;originWidth=1070&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>增加一个 QC 普通队列声明后并绑定交换机 XC。<br>队列配置 中添加：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------------------------------优化延迟队列-------------------------------------</span></span><br><span class="line">    <span class="comment">//普通队列的名称（为了优化延迟队列）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_C = <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明QC</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信routing-key</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定普通队列QC和交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueCBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-----------------------------------优化延迟队列----------------------------------</span></span><br></pre></td></tr></table></figure><p>添加 Controller 发消息控制器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始发消息  消息ttl</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendExpireMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> String ttlTime)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一条时长&#123;&#125;毫秒，ttl信息给队列QC:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), ttlTime, message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message, msg -&gt; &#123;</span><br><span class="line">            <span class="comment">//发送消息的时候  延迟时长</span></span><br><span class="line">            msg.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试：</p><ol><li><a href="http://localhost:8080/ttl/sendExpireMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpireMsg/你好</a> 1/20000</li><li><a href="http://localhost:8080/ttl/sendExpireMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpireMsg/你好</a> 2/2000</li></ol><p>结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638517312025-dfbbfd0b-a82c-4432-a395-2e7cc7c6e48f.png#clientId=u7522214d-0203-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=149&amp;id=u18e59259&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=149&amp;originWidth=1285&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=42107&amp;status=done&amp;style=none&amp;taskId=uff6fb06a-df03-451f-b886-52364055048&amp;title=&amp;width=1285#id=efjYm&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="延迟队列（基于插件）">延迟队列（基于插件）</h2><p>进入 rabbitmq 安装目录下的 plugins 目录 ，cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins<br>执行命令让该插件生效：rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br>然后重启 rabbitmq：systemctl restart rabbitmq-server<br>会发现交换机多了一个新类型，意味着延迟消息将由交换机来完成，而不是队列。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638519642120-f3258006-3639-4551-805e-26bbd1e67c85.png#clientId=u7522214d-0203-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=530&amp;id=u66b7d498&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=767&amp;originWidth=690&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=56472&amp;status=done&amp;style=none&amp;taskId=u707609ca-e368-4b6c-9833-ec8cc57ca15&amp;title=&amp;width=477.00006103515625#id=PD1AH&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><p>原来的情况：基于死信<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638520455616-cfcde47e-bee3-4ef6-83b6-6630dbe54d9a.png#clientId=u7522214d-0203-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=443&amp;id=ua9957719&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=601&amp;originWidth=1033&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=226301&amp;status=done&amp;style=none&amp;taskId=ua95f3b09-635a-4782-abfd-57901f34a8b&amp;title=&amp;width=760.9862060546875#id=UOPGa&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>现在：基于延迟插件<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638520591056-7591eaf6-b99f-4059-8cbb-6a6ee0ea64f2.png#clientId=u7522214d-0203-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=177&amp;id=u11577081&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=224&amp;originWidth=976&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=94107&amp;status=done&amp;style=none&amp;taskId=u47b17a31-4f94-4f3c-a75f-2014f181765&amp;title=&amp;width=770.9896240234375#id=a4gyh&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>代码架构：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638520764180-7b9e927e-1166-470d-ac32-dda16bb87ae1.png#clientId=u7522214d-0203-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=188&amp;id=ud9b4ba5b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=188&amp;originWidth=1062&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=84300&amp;status=done&amp;style=none&amp;taskId=u12c568cb-6151-4b2f-8f49-3f721530b6d&amp;title=&amp;width=1062#id=cPAio&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ol><li>配置类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/3 16:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delayed.name&quot;</span>;</span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//routing-key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DELAYED_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明交换机 基于插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">delayedExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 交换机的名称</span></span><br><span class="line"><span class="comment">         * 2. 交换机的类型</span></span><br><span class="line"><span class="comment">         * 3. 是否需要持久化</span></span><br><span class="line"><span class="comment">         * 4. 是否需要自动删除</span></span><br><span class="line"><span class="comment">         * 5. 其他的参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayedQueueBindingDelayedExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue delayedQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Controller 生产者：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发消息  基于延迟插件</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> Integer delayTime)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间:&#123;&#125;,发送一条时长&#123;&#125;毫秒信息给延迟队列delayed.queue:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), delayTime, message);</span><br><span class="line">        rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME, DelayedQueueConfig.DELAYED_ROUTING_KEY, message, msg -&gt; &#123;</span><br><span class="line">            <span class="comment">//发送消息的时候   延迟时长  单位：ms</span></span><br><span class="line">            msg.getMessageProperties().setDelay(delayTime);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>消费者：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.springbootrabbitmq.config.DelayedQueueConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/3 19:36</span></span><br><span class="line"><span class="comment"> * 消费者 基于插件的延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//监听消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveDelayQueue</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间:&#123;&#125;,收到延迟队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br>发起请求：<a href="http://localhost:8080/ttl/sendDelayMsg/com">http://localhost:8080/ttl/sendDelayMsg/com</a> on baby1/20000<br><a href="http://localhost:8080/ttl/sendDelayMsg/com">http://localhost:8080/ttl/sendDelayMsg/com</a> on baby2/2000<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638532349237-315b969f-d021-4448-8aa8-d5a1d41950a0.png#clientId=u44e4b0cf-fc9d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=208&amp;id=uf33e7fe7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=208&amp;originWidth=1432&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=71640&amp;status=done&amp;style=none&amp;taskId=ue722c22b-16d9-40a2-9a28-e95348df5d0&amp;title=&amp;width=1432#id=P79jF&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638532663153-40afab72-d363-4536-94fc-4889e40d764b.png#clientId=u44e4b0cf-fc9d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=224&amp;id=u7813c3ed&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=266&amp;originWidth=1121&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=457006&amp;status=done&amp;style=none&amp;taskId=u0e4002d8-2179-43cc-bcfd-7c69cd127b5&amp;title=&amp;width=941.9896240234375#id=aEVGf&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="发布确认高级">发布确认高级</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638533419869-3aa9b7ad-ee4e-4fd8-9e42-fd6af4aafe70.png#clientId=u44e4b0cf-fc9d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=225&amp;id=u7ed4e098&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=341&amp;originWidth=945&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=186643&amp;status=done&amp;style=none&amp;taskId=uc65852ff-c2a9-416e-bef6-2991c80fa8b&amp;title=&amp;width=623.0000610351562#id=OAmnb&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638533456413-9ead4e1d-f118-4a55-8d05-bcdd4d5fc47f.png#clientId=u44e4b0cf-fc9d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=131&amp;id=u954992f9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=144&amp;originWidth=839&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=73103&amp;status=done&amp;style=none&amp;taskId=u9819bc42-f398-487a-b319-358e2acd1ba&amp;title=&amp;width=762.9931030273438#id=sjopK&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="回调接口-若交换机收不到消息">回调接口 : (若交换机收不到消息)</h3><ol><li>配置类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/3 20:15</span></span><br><span class="line"><span class="comment"> * 配置类  发布确认 （高级）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//routing-key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_ROUTING_KEY = <span class="string">&quot;key1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定交换机和队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBindingExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>生产者：发消息</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.springbootrabbitmq.config.ConfirmConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/3 20:27</span></span><br><span class="line"><span class="comment"> * 开始发消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME, ConfirmConfig.CONFIRM_ROUTING_KEY, message, correlationData);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容为：&#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>消费者：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.springbootrabbitmq.config.ConfirmConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/3 20:33</span></span><br><span class="line"><span class="comment"> * 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfirmMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接收到的队列confirm.queue消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>回调接口</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/3 20:50</span></span><br><span class="line"><span class="comment"> * 回调接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注入 （需要将当前实现类注入到RabbitTemplate的ConfirmCallback函数式接口中）</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法</span></span><br><span class="line"><span class="comment">     * 1. 发消息  交换机接收到了  回调</span></span><br><span class="line"><span class="comment">     * 1.1 correlationData 保存回调消息的id及相关信息</span></span><br><span class="line"><span class="comment">     * 1.2 交换机收到消息  ack = true</span></span><br><span class="line"><span class="comment">     * 1.3 cause  null</span></span><br><span class="line"><span class="comment">     * 2. 发消息 交换机接收失败 回调</span></span><br><span class="line"><span class="comment">     * 2.1 correlationData 保存回调消息的id及相关信息</span></span><br><span class="line"><span class="comment">     * 2.2 交换机收到消息 ack = false</span></span><br><span class="line"><span class="comment">     * 2.3 cause  失败的原因</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到id为：&#123;&#125;的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;交换机还未收到id为:&#123;&#125;的消息，由于原因：&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638537772169-a45dc229-e5ed-410a-8e46-69f3fb39f21e.png#clientId=u44e4b0cf-fc9d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=518&amp;id=u396acbb1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=518&amp;originWidth=973&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=369736&amp;status=done&amp;style=none&amp;taskId=u8a93ee99-1d87-4fd1-880d-a166a5e50f1&amp;title=&amp;width=973#id=Bk8N5&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: <span class="number">59.110</span><span class="number">.171</span><span class="number">.189</span></span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: admin</span><br><span class="line">    password: <span class="number">123</span></span><br><span class="line">    publisher-confirm-type: correlated    # 消息确认机制</span><br></pre></td></tr></table></figure><ol start="5"><li>发送请求 : <a href="http://localhost:8080/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD">http://localhost:8080/confirm/sendMessage/大家好</a> 1</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638537854600-e11783cd-28be-4b75-8f36-434ecab3f990.png#clientId=u44e4b0cf-fc9d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=190&amp;id=ue332f12f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=190&amp;originWidth=1135&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=51915&amp;status=done&amp;style=none&amp;taskId=uba52e997-898f-49e3-9067-645cfb69f68&amp;title=&amp;width=1135#id=Emijw&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ol start="6"><li>测试交换机收不到消息：在发送消息中，将交换机名字后面拼接上&quot;123&quot;，再次启动，发送请求： <a href="http://localhost:8080/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD">http://localhost:8080/confirm/sendMessage/大家好</a> 1</li></ol><p>会得到：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638538268620-8dcbc2ae-eaa1-4b60-8822-9cd20f509c52.png#clientId=u44e4b0cf-fc9d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=222&amp;id=u3e470d69&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=222&amp;originWidth=1872&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=66288&amp;status=done&amp;style=none&amp;taskId=u7f0330f7-a846-488e-8b25-71c1f3cf0a7&amp;title=&amp;width=1872#id=J3ZRH&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ol start="7"><li>测试队列收不到消息</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.springbootrabbitmq.config.ConfirmConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/3 20:27</span></span><br><span class="line"><span class="comment"> * 开始发消息  生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">        CorrelationData correlationData1 = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                ConfirmConfig.CONFIRM_ROUTING_KEY, message, correlationData1);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容为：&#123;&#125;&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">        CorrelationData correlationData2 = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                ConfirmConfig.CONFIRM_ROUTING_KEY+<span class="string">&quot;2&quot;</span>, message, correlationData2);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容为：&#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638538743381-bfc4680e-692b-4303-a0f3-87cd9425978d.png#clientId=u44e4b0cf-fc9d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=247&amp;id=u241a2996&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=247&amp;originWidth=1157&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=67266&amp;status=done&amp;style=none&amp;taskId=u3edf7078-e740-4b0a-866c-03de3cfb9db&amp;title=&amp;width=1157#id=SGy2Z&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>可见，队列没有收到消息，也没有应答和确认。</p><h3 id="若队列收不到消息">若队列收不到消息</h3><h4 id="回退消息">回退消息</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638539584832-557a9bbc-89d4-4162-a0d4-599eb7f3df21.png#clientId=u44e4b0cf-fc9d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=210&amp;id=u40b5093d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=210&amp;originWidth=976&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=298616&amp;status=done&amp;style=none&amp;taskId=u13a46749-be43-4430-beb2-483ea013efc&amp;title=&amp;width=976#id=thCkG&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: <span class="number">59.110</span><span class="number">.171</span><span class="number">.189</span></span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: admin</span><br><span class="line">    password: <span class="number">123</span></span><br><span class="line">    publisher-confirm-type: correlated   # 消息确认机制</span><br><span class="line">    publisher-returns: true       # 发布确认机制（消息在交换机那若路由失败，则会回退消息给生产者）</span><br></pre></td></tr></table></figure><p>回退接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注入</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注入 （需要将当前实现类注入到RabbitTemplate的ConfirmCallback函数式接口中）</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以在当消息传递过程中，不可达目的地时将消息返回给生产者</span></span><br><span class="line"><span class="comment">     * 只有不可到目的地时，才进行回退</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnedMessage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息&#123;&#125;，被交换机&#123;&#125;退回，退回原因：&#123;&#125;,路由key:&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> String(returnedMessage.getMessage().getBody()),</span><br><span class="line">                returnedMessage.getExchange(),</span><br><span class="line">                returnedMessage.getReplyText(),</span><br><span class="line">                returnedMessage.getRoutingKey());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638542234889-03b41ef6-8fc5-4ffb-9f36-7287d4ff9476.png#clientId=u44e4b0cf-fc9d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=267&amp;id=uddd5e8ec&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=267&amp;originWidth=1293&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=78730&amp;status=done&amp;style=none&amp;taskId=u4c513758-cf34-415c-a9f3-845a33faec5&amp;title=&amp;width=1293#id=tOHQ4&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h4 id="备份交换机">备份交换机</h4><p>添加一个交换机和两个队列。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638578627259-759238ba-aac5-42f9-b645-401c5c9a05d2.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=328&amp;id=ud35a1613&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=328&amp;originWidth=930&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=197049&amp;status=done&amp;style=none&amp;taskId=u04e4ef45-34c3-49a8-84c0-93d70b4ebb6&amp;title=&amp;width=930#id=j2ALj&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ol><li>配置类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/3 20:15</span></span><br><span class="line"><span class="comment"> * 配置类  发布确认 （高级）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//routing-key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_ROUTING_KEY = <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">    <span class="comment">// --------------------------备份交换机---------------------------------</span></span><br><span class="line">    <span class="comment">//备份交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_EXCHANGE_NAME = <span class="string">&quot;backup_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_QUEUE_NAME = <span class="string">&quot;backup_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//报警队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WARNING_QUEUE_NAME = <span class="string">&quot;warning_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//声明确认交换机（要转发到备份交换机）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(<span class="keyword">true</span>)</span><br><span class="line">                .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定交换机和队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBindingExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">backupExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(BACKUP_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">backupQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//报警队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">warningQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定（备份交换机和备份队列）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">backupQueueBindingBackupExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange, <span class="meta">@Qualifier(&quot;backupQueue&quot;)</span> Queue backupQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定（备份交换机和报警队列）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">warningQueueBindingBackupExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange, <span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue warningQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>消费者（报警消费者）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.springbootrabbitmq.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.springbootrabbitmq.config.ConfirmConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/12/4 9:10</span></span><br><span class="line"><span class="comment"> * 报警消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarningConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收报警消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveWarningMsg</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.error(<span class="string">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送请求：<a href="http://localhost:8080/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD">http://localhost:8080/confirm/sendMessage/大家好</a> 1<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638581402507-07326d95-5109-4750-b3ab-c4751b23d55d.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=263&amp;id=udc9907e1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=263&amp;originWidth=1171&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=75848&amp;status=done&amp;style=none&amp;taskId=u7fb8b716-7979-4acf-b11c-fe1cb99bebd&amp;title=&amp;width=1171#id=Lep12&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><blockquote><p><strong>备份交换机的优先级高于回退消息、</strong></p></blockquote><h2 id="其他知识点">其他知识点</h2><h3 id="幂等性">幂等性</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638581856478-4611604a-34c1-486b-a3b7-c809f3d94f0e.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=620&amp;id=ua03a1a2a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=620&amp;originWidth=977&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=628166&amp;status=done&amp;style=none&amp;taskId=u3bbefde1-d01a-481e-b831-abe2598835f&amp;title=&amp;width=977#id=pWlKw&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638582165848-9189cc73-c68b-4631-b30d-dad30387a032.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=523&amp;id=u37f187c9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=523&amp;originWidth=1001&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=609037&amp;status=done&amp;style=none&amp;taskId=udd6ff171-0753-4d6f-a510-a8761c65fcb&amp;title=&amp;width=1001#id=o6DXP&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="优先级队列">优先级队列</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638582363595-025332ba-94e1-4485-b6ab-e0542d69fab7.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=326&amp;id=u83200fbd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=326&amp;originWidth=987&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=447217&amp;status=done&amp;style=none&amp;taskId=ueea7db03-7906-4cef-baef-0ebe50a0185&amp;title=&amp;width=987#id=h3cca&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638582579936-dd221c3d-efc6-4e4b-b854-6667d27682a1.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=343&amp;id=u3930b1c7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=402&amp;originWidth=1186&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=288467&amp;status=done&amp;style=none&amp;taskId=u70a2eadf-0b86-470c-a5a8-b7d8f612ad3&amp;title=&amp;width=1010.9896240234375#id=WVQYU&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>实现优先级:</p><ol><li>生产者：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/11/28 22:15</span></span><br><span class="line"><span class="comment"> * 生产者 ：发消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line"><span class="comment">//        ConnectionFactory factory = new ConnectionFactory();</span></span><br><span class="line"><span class="comment">//        //设置工厂ip  连接rabbitmq的队列</span></span><br><span class="line"><span class="comment">//        factory.setHost(&quot;59.110.171.189&quot;);</span></span><br><span class="line"><span class="comment">//        //用户名</span></span><br><span class="line"><span class="comment">//        factory.setUsername(&quot;admin&quot;);</span></span><br><span class="line"><span class="comment">//        //密码</span></span><br><span class="line"><span class="comment">//        factory.setPassword(&quot;123&quot;);</span></span><br><span class="line"><span class="comment">//        //创建连接</span></span><br><span class="line"><span class="comment">//        Connection connection = factory.newConnection();</span></span><br><span class="line"><span class="comment">//        //获取信道</span></span><br><span class="line"><span class="comment">//        Channel channel = connection.createChannel();</span></span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * 参数；1.队列名称</span></span><br><span class="line"><span class="comment">         *      2.队列里面的消息是否持久化（磁盘），默认消息存储在内存中（不持久化false）</span></span><br><span class="line"><span class="comment">         *      3.该队列是否只供一个消费者进行消费，是否消息独有，true只允许一个消费者进行消费，默认是false（可以多个消费者消费）</span></span><br><span class="line"><span class="comment">         4. 是否自动删除，最后一个消费者断开连接后，该队列是否自动删除，true自动删除，false不自动删除</span></span><br><span class="line"><span class="comment">         5.其他参数（延迟消息......）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//官方允许是0-255之间。此处设置10. 允许优先级范围为0-10   不要设置过大   浪费CPU与内存</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">        <span class="comment">//发消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">//设置优先级</span></span><br><span class="line">                AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 发送一个消息</span></span><br><span class="line"><span class="comment">         * 1. 发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * 2. 路由的key值是哪个，本次是队列的名称</span></span><br><span class="line"><span class="comment">         * 3. 其他参数信息</span></span><br><span class="line"><span class="comment">         * 4. 发送消息的消息体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动生产者：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638584428018-a99005d9-2193-463c-9f45-3f72656510ca.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=245&amp;id=u9109bfc5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=245&amp;originWidth=673&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=24479&amp;status=done&amp;style=none&amp;taskId=u0a4a6f5a-f03f-4ab3-8fcc-d9bdc327aad&amp;title=&amp;width=673#id=shKB3&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="image-png-v2"><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638584267331-0bf02c8d-6536-43a8-aa18-ee5f4ed82255.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=500&amp;id=AvLAP&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=500&amp;originWidth=1065&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=74831&amp;status=done&amp;style=none&amp;taskId=u77c77f80-cfec-453b-bc9f-f82bf26b07c&amp;title=&amp;width=1065#id=cIQXz&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></h3><ol start="2"><li>消费者 :</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.rabbitmq.utils.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LiFang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/11/29 15:04</span></span><br><span class="line"><span class="comment"> * 消费者:接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line"><span class="comment">//        ConnectionFactory factory = new ConnectionFactory();</span></span><br><span class="line"><span class="comment">//        factory.setHost(&quot;59.110.171.189&quot;);</span></span><br><span class="line"><span class="comment">//        factory.setUsername(&quot;admin&quot;);</span></span><br><span class="line"><span class="comment">//        factory.setPassword(&quot;123&quot;);</span></span><br><span class="line"><span class="comment">//        Connection connection = factory.newConnection();</span></span><br><span class="line"><span class="comment">//        Channel channel = connection.createChannel();</span></span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明 接收消息(成功后的回调)</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消息时的回调</span></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 消费者 消费消息</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2. 消费成功之后是否要自动应答，true代表自动应答,false代表手动应答。</span></span><br><span class="line"><span class="comment">         * 3. 消费者未成功消费的回调。</span></span><br><span class="line"><span class="comment">         * 4. 消费者取消消费的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动消费者，<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638584610103-d784c402-b9b7-4321-80d9-c4b95990f410.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=346&amp;id=u91a8ee8e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=346&amp;originWidth=652&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36450&amp;status=done&amp;style=none&amp;taskId=u90a3da53-d612-4152-b8b6-157c3e789ca&amp;title=&amp;width=652#id=UEHzd&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="惰性队列">惰性队列</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638584657059-9bf42f28-e7a0-4c4f-8a39-c56038bd0071.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=425&amp;id=ud4e3da7e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=425&amp;originWidth=993&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=597255&amp;status=done&amp;style=none&amp;taskId=u2ff8ea80-3715-4c63-a718-4d71e1b8488&amp;title=&amp;width=993#id=wMAkZ&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638584904322-348e89b5-e2f2-4df0-ba11-7540a061f849.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=613&amp;id=u9cab5578&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=613&amp;originWidth=1175&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=404748&amp;status=done&amp;style=none&amp;taskId=uc0905b86-a7ec-4a0f-8a69-356a47ad688&amp;title=&amp;width=1175#id=NaNR3&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>惰性队列执行性能不太好，因此默认情况下不使用惰性队列，而使用正常队列。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638585096408-ecb74216-dfa9-41e3-b7bd-bd5236b2c1da.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=431&amp;id=u4ab29e59&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=431&amp;originWidth=967&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=466179&amp;status=done&amp;style=none&amp;taskId=ub1da4c7a-e46a-44f7-9b2f-e5129f4a839&amp;title=&amp;width=967#id=ZtuGu&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638585305462-e73859d4-5121-406a-b308-57cede7f1bac.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=413&amp;id=uf8c1b8a8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=413&amp;originWidth=966&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=247424&amp;status=done&amp;style=none&amp;taskId=ua29dd158-1851-4974-bd9b-3c01a9c0ea5&amp;title=&amp;width=966#id=wFSJu&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><ul><li>惰性队列从<strong>磁盘</strong>上读取消息，因此消费消息比较慢，但是内存消耗较小，在内存中只存储一些索引。一旦需要消费这些消息时，惰性队列会通过内存中的索引，去读取磁盘中相应的消息，到内存，再消费消息。</li><li>正常队列从<strong>内存</strong>中读取消息，因此消费消息比较快，但是内存消耗较大。</li></ul><h2 id="rabbitmq-集群">rabbitmq 集群</h2><h3 id="集群原理">集群原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638586666884-b99e8e77-81ef-4547-a9cd-1dcd00e86009.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=501&amp;id=u84ce9d05&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=501&amp;originWidth=1025&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=171726&amp;status=done&amp;style=none&amp;taskId=ud7aa0990-8e0c-4e31-9dd1-c6d20007401&amp;title=&amp;width=1025#id=hjXVB&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="镜像队列（备份）">镜像队列（备份）</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638587610363-c97ef89e-768e-4278-a087-89f20e211145.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=348&amp;id=ue8695270&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=348&amp;originWidth=981&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=453959&amp;status=done&amp;style=none&amp;taskId=ue9f78068-c45e-4cc9-a3e0-595ae6c7337&amp;title=&amp;width=981#id=FTNYI&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h3 id="高可用负载均衡">高可用负载均衡</h3><p>若节点 1 宕机了，生产者需要连接节点 2 或节点 3。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638588031855-ab97c0f3-9861-4222-b593-0a4dbfbf566d.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=754&amp;id=u0c60fb59&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=754&amp;originWidth=1028&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=344345&amp;status=done&amp;style=none&amp;taskId=uaef85042-099b-42a3-8caf-268a89b7438&amp;title=&amp;width=1028#id=XmCHx&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>出现问题：生产者无法变更 rabbitmq 的 ip，此时需要借助外力 Haproxy。</p><h4 id="Haproxy-实现高可用-负载均衡（高并发）">Haproxy 实现高可用 负载均衡（高并发）</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638588332155-384a9066-f6ed-434c-bd8d-a08678795b99.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=177&amp;id=u91155287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=177&amp;originWidth=973&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=240431&amp;status=done&amp;style=none&amp;taskId=u9a4dff8d-f824-447c-b845-2962ddc0650&amp;title=&amp;width=973#id=BHuXj&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638588403571-837d2496-d169-4b00-aa3c-4459e5dfd616.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=644&amp;id=u63b0c105&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=644&amp;originWidth=740&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=224363&amp;status=done&amp;style=none&amp;taskId=u400f5630-901e-4db7-8556-6d72a1f206a&amp;title=&amp;width=740#id=FRrD8&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638588495639-57e1823e-e317-48f1-bd99-4a64ab26b8b3.png#clientId=ueb126df1-e3fc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=711&amp;id=uefaa64c3&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=711&amp;originWidth=860&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=371827&amp;status=done&amp;style=none&amp;taskId=u8f30ca6f-4949-4c9d-899d-b31600baa56&amp;title=&amp;width=860#id=K5Fpn&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="联合交换机">联合交换机</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638600972390-f8eabb13-fdba-432b-8b93-c4798757e13e.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=660&amp;id=u1565c7a2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=660&amp;originWidth=1136&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=882067&amp;status=done&amp;style=none&amp;taskId=u40ae3ed4-1bbc-4baa-b912-40f55e8b353&amp;title=&amp;width=1136#id=FkHCS&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638601768985-91857261-fe17-4687-bc9f-f8d9daf1a364.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=524&amp;id=uafeaba48&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=524&amp;originWidth=1115&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=307899&amp;status=done&amp;style=none&amp;taskId=u4499a665-a618-4138-a2f2-5bdf1dbaca0&amp;title=&amp;width=1115#id=FgJli&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638601930969-0c445ecb-7e66-43cd-a7d1-3aa8c76f884d.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=581&amp;id=u6d4c749b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=581&amp;originWidth=505&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=221677&amp;status=done&amp;style=none&amp;taskId=uf8d981fd-837f-4eb6-83f6-a7deba0a018&amp;title=&amp;width=505#id=NxTl9&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638602088334-f76d8ba1-5c6d-4280-87c8-b7d58d42f902.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=506&amp;id=u4b7146f5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=506&amp;originWidth=976&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=158537&amp;status=done&amp;style=none&amp;taskId=u64d80530-7388-4c12-9d3b-48d90765e0b&amp;title=&amp;width=976#id=oVYwK&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638602110103-8ee2df46-7982-4b08-a6c8-e4d9c701b69f.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=666&amp;id=u65df8122&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=666&amp;originWidth=933&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=302115&amp;status=done&amp;style=none&amp;taskId=u970ef30c-4b50-4327-928e-6bf0cdbc242&amp;title=&amp;width=933#id=A9wRm&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="联邦队列">联邦队列</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638602602857-2efc1842-e9c7-409e-a302-2b4c63e92027.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=833&amp;id=u3d500d40&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=833&amp;originWidth=1312&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=553687&amp;status=done&amp;style=none&amp;taskId=u77ecfe28-0a6d-4318-bc8e-c80d6183ecc&amp;title=&amp;width=1312#id=qvMwP&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br>两个不同地区数据同步。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638603240478-ba4a3a39-d3dc-41b3-9ee9-c8d9f2718ff9.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=551&amp;id=u0dc6d91b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=551&amp;originWidth=1149&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=244288&amp;status=done&amp;style=none&amp;taskId=u65c1251d-b002-4909-ae1d-f27aa9d85ee&amp;title=&amp;width=1149#id=Rmak1&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p><h2 id="Shovel">Shovel</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638603352779-28d006e0-d330-4802-935c-040341c1ca8d.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=324&amp;id=uc852da4a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=324&amp;originWidth=1287&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=568699&amp;status=done&amp;style=none&amp;taskId=u2b770501-53fa-4cbc-a428-000590e2c17&amp;title=&amp;width=1287#id=fxL0i&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638603460089-03466d04-df20-4ab2-8968-f1b5ef5905ca.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=409&amp;id=ua502f49e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=409&amp;originWidth=871&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=188661&amp;status=done&amp;style=none&amp;taskId=u48a08d45-4dad-40e0-9723-55db3e3ef79&amp;title=&amp;width=871#id=lh1tz&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638603378352-15aca4d9-af9b-48c1-b796-60a86b637ebd.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=667&amp;id=uec9ad770&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=667&amp;originWidth=864&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=266940&amp;status=done&amp;style=none&amp;taskId=u8acd6a6e-3ed2-4306-8639-2eeb16612c3&amp;title=&amp;width=864#id=jpTqS&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638603594801-6bd296a5-c23b-418f-a94e-5261833d5605.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=592&amp;id=u903663bb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=592&amp;originWidth=994&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=194438&amp;status=done&amp;style=none&amp;taskId=ud10d2c55-8f5b-4b88-b096-8942402c361&amp;title=&amp;width=994#id=oSJ3T&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2324645/1638603639753-9ae10564-7bad-4528-afd2-867c58d1f413.png#clientId=u1823549f-f362-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=121&amp;id=u71e6fa9c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=121&amp;originWidth=1169&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=88867&amp;status=done&amp;style=none&amp;taskId=u55070310-f786-4b38-98ce-55db2f75ca1&amp;title=&amp;width=1169#id=Gjcgc&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/6afde458ad52/"/>
      <url>/posts/6afde458ad52/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>[Welcome to <a href="%5Bhttps://hexo.io/">Hexo</a>!](<a href="https://hexo.io/">https://hexo.io/</a>)!) This is your very first post. Check <a href="%5Bhttps://hexo.io/docs/">documentation</a>](<a href="https://hexo.io/docs/">https://hexo.io/docs/</a>)) for more info. If you get any problems when using Hexo, you can find the answer in <a href="%5Bhttps://hexo.io/docs/troubleshooting.html">troubleshooting</a>](<a href="https://hexo.io/docs/troubleshooting.html">https://hexo.io/docs/troubleshooting.html</a>)) or you can ask me on <a href="%5Bhttps://github.com/hexojs/hexo/issues">GitHub</a>.](<a href="https://github.com/hexojs/hexo/issues">https://github.com/hexojs/hexo/issues</a>).##)</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash$ hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>More info: <a href="%5Bhttps://hexo.io/docs/writing.html">Writing</a>](<a href="https://hexo.io/docs/writing.html">https://hexo.io/docs/writing.html</a>)###)</p><h3 id="Run-server">Run server</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="%5Bhttps://hexo.io/docs/server.html">Server</a>](<a href="https://hexo.io/docs/server.html">https://hexo.io/docs/server.html</a>)###)</p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="%5Bhttps://hexo.io/docs/generating.html">Generating</a>###](<a href="https://hexo.io/docs/generating.html">https://hexo.io/docs/generating.html</a>)###) Deploy to remote sites</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="%5Bhttps://hexo.io/docs/one-command-deployment.html">Deployment</a>](<a href="https://hexo.io/docs/one-command-deployment.html">https://hexo.io/docs/one-command-deployment.html</a>))</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
