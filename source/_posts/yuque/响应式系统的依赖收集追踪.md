---
title: 响应式系统的依赖收集追踪原理
categories: 原理
date: 2022-12-02
updated: 2022-12-02
tags: [响应式, 依赖收集]
cover: https://img2.baidu.com/it/u=666190161,269174072&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=313
---

## 为什么要依赖收集？

观察数据的目的：当数据的属性发生变化时，可以通知哪些曾经使用了该数据的地方。
如果多个 Vue 实例共用了一个变量，此时，我们需要通知这多个 Vue 实例进行视图更新，我们只有收集依赖才能知道哪些地方依赖我的数据，以及数据更新时派发更新。
依赖收集如何实现的？核心思想：事件发布订阅模式。

## 订阅者 Dep

### 为什么引入 Dep

收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。
因此，我们先实现一个订阅者 Dep 类，用于解耦属性的依赖收集和派发更新操作，具体来说，Dep 的主要作用是：用来存放 Watcher 观察者对象。可以把 Watcher 看成一个中介的角色，数据发生变化时，通知它，然后它再通知其他地方。

### Dep 简单实现

```js
class Dep {
  constructor() {
    /* 用来存储Watcher对象的数组 */
    this.subs = [];
  }
  /* 在subs中添加一个Watcher对象 */
  addSub(sub) {
    this.subs.push(sub);
  }
  /** 通知所有Watcher对象更新视图 **/
  notify() {
    this.subs.forEach((sub) => {
      sub.update();
    });
  }
}
```

> 以上代码主要做两件事情：

- 用 addSub 方法可以在目前的 Dep 对象中增加一个 Watcher 的订阅操作；
- 用 notify 方法通知目前 Dep 对象的 subs 中的所有 Watcher 对象触发更新操作。
  所以，当需要依赖收集时，调用 addSub，当需要派发更新时，调用 notify。
  如何调用？

```js
let dp = new Dep();
dp.addSub(() => {
  console.log("emit here");
});
dp.notify();
```

## 观察者 Watcher

### 为什么引入 Watcher

Vue 中定义一个 Watcher 类来表示观察订阅依赖。

为什么引入 Watcher？

    当属性发生变化后，我们要通知用到数据的地方，而使用这个数据的地方有很多，而且类型也不一样，既可能是模板，也有可能是用户写的一个watch，这时需要抽象出一个能集中处理这些情况的类。

    然后，我们在依赖收集阶段，只收集这个封装好的类的实例进来，通知也通知它一个，再由它负责通知其他地方。

**依赖收集的目的：** 将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/8/16bcf314e67ca21d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

### 简单实现 Watcher

```js
class Watcher {
  constructor(obj, key, cb) {
    /**
     * 将Dep.target指向自己
     * 然后触发属性的getter添加监听
     * 最后将Dep.target置空
     */
    Dep.target = this;
    this.cb = cb;
    this.obj = obj;
    this.key = key;
    this.value = obj[key];
    Dep.target = null;
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key];
    this.cb(this.value);
  }
}
```

> 在执行构造函数时，将 Dep.target 指向自身，从而使得收集到了对应的 Watcher，在派发更新时取出对应的 Watcher，然后执行 update 函数。

## 收集依赖

所谓依赖，就是 Watcher。
如何收集依赖？**在 getter 中收集依赖，在 setter 中触发依赖。** 先收集依赖，即把用到该数据的地方收集起来，然后等属性发生变化时，把之前收集好的依赖循环触发一遍即可。

具体来说，当外界通过 Watcher 读取数据时，就会触发 getter 从而将 Watcher 添加到依赖中，哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。

最后我们对 defineReactive 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码，实现一个简易的数据响应式。

```js
function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== "object") {
    return;
  }
  Object.keys(obj).forEach((key) => {
    defineReactive(obj, key, obj[key]);
  });
  function defineReactive(obj, key, value) {
    observe(value); // 递归子属性
    let dp = new Dep(); // 新增
    Object.defineProperty(obj, key, {
      enumerable: true, //  可枚举 （可遍历）
      configurabele: true, // 可配置 （比如 可以删除）
      get: function reactiveGetter() {
        console.log("get", value); // 监听
        // 将Watcher添加到订阅
        if (Dep.target) {
          dp.addSub(Dep.target); // 新增
        }
        return value;
      },
      set: function reactiveSetter(newVal) {
        observe(newVal); // 如果赋值是一个对象，也要递归子属性
        if (newVal !== value) {
          console.log("set", newVal); // 监听
          render();
          value = newVal;
          // 执行watcher的update方法
          dp.notify(); // 新增
        }
      },
    });
  }
}
class Vue{
    constructor (options){
        this._data = options.data
        observe(this._data))
        /* 新建一个Watcher观察者对象，这时Dep.target会指向这个Watcher对象 */
        new Watcher()
        console.log('模拟视图渲染')
    }
}
```

当 render function 被渲染时，读取所需对象的值，会触发 reactiveGetter 函数把当前的 Watcher 对象（存放在 Dep.target 中）收集到 Dep 类中去。之后如果修改对象的值，则会触发 reactiveSetter 方法，通知 Dep 类调用 notify 来触发所有 Watcher 对象的 update 方法更新对应视图。

## 总结

1. 在 observer 过程中会注册 get 方法，该方法用来进行**依赖收集**。 在它的闭包中有一个 Dep 对象（用来存放 Watcher 对象的实例）。

   **依赖收集**的过程：把 Watcher 实例存放到对应的 Dep 对象中去。

   get 方法可以让当前的 Watcher 对象（Dep.target）存放到它的 subs 中（addSub 方法）；

   在数据变化时，set 会调用 Dep 对象的 notify 方法通知它内部所有的 Watcher 对象进行视图更新。

   这是 Object.defineProperty 的 set/get 方法处理的事情，那么依赖收集的前提条件还有两个：

   - 触发 get 方法
   - 新建一个 Watcher 对象

   在 Vue 的构造类中处理，新建一个 Watcher 对象只需 new 出来，此时，Dep.target 已经指向了这个 new 出来的 Watcher 对象。

   如何触发 get 方法？把 render function 进行渲染，则其中的依赖的对象会被读取。
