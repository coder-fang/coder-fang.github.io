---
title: JS函数式编程
categories: JS
date: 2022-12-05
updated: 2022-12-05
tags: JS
cover:
---

## 什么是函数式编程

是一种编程范式，主要是利用函数把运算过程封装起来，通过组合各种函数来计算结果。使用函数式编程，可以在更短时间内编写具有更好错误的代码。

函数式编程的两个基本特点：

- 通过函数来对数据进行转换
- 通过串联多个函数来求结果

### 声明式与命令式之对比

- 命令式：通过编写一条又一条指令去让计算机执行一些动作，一般会涉及到很多繁杂的细节。命令式代码中频繁使用语句来完成某个行为，如 for、if、switch、throw 等语句。
- 声明式：通过写表达式的方式来声明我们想干什么，而不是通过一步步的指示。表达式通常是某些函数调用的复合、一些值和操作符，用来计算出结果。

函数式编程的好处：声明式的代码对于无副作用的纯函数，可以不考虑函数内部是如何实现的，专注于编写业务代码。

## 特性

### 无副作用

调用函数时不会修改外部状态，即一个函数调用 n 次后依然返回同样的结果。

例如：

```js
var a = 1;
// 含有副作用，它修改了外部变量a
// 多次调用结果不一样
function test() {
  a++;
  return a;
}
// 无副作用，没有改外部状态
// 多次调用结果一样
function test1(a) {
  return a + 1;
}
```

### 透明调用

一个函数只会用到传递给它的变量及自己内部创建的变量，不会使用到其他变量。

```js
var a = 1;
var b = 2;
// 函数内部使用的变量并不属于它的作用域
function test1() {
  return a + b;
}
// 函数内部使用的变量是显式传递进去的
function test2(a, b) {
  return a + b;
}
```

### 不可变变量

一个变量一旦创建后，就不能再进行修改，任何修改都会生成一个新的变量。

使用不可变变量最大的好处：线程安全。
多个线程可以同时访问同一个不可变变量，让并行十分容易实现。
由于 JS 原生不支持不可变变量，需要通过第三方库来实现。（如 Immutable.js，Mori 等）

### 函数的地位

JS 的“第一等公民”是函数。函数和其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或作为别的函数的返回值。

## 常见的函数式编程模型

### 闭包

如果一个函数引用了自由变量，那么该函数是一个闭包。
自由变量是指不属于该函数作用域的变量（所有全局变量都是自由变量，严格来说，引用了全局变量的函数都是闭包，但这种闭包并没有什么用，通常情况下闭包是指函数内部的函数）。

闭包形成的条件：

- 存在内、外两层函数
- 内层函数对外层函数的局部变量进行了引用

闭包的用途：可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或计算的中间量等。

```js
// 写一个简单的缓存工具
const cache = (function () {
  const store = {};
  return {
    get(key) {
      return store[key];
    },
    set(key, val) {
      store[key] = val;
    },
  };
})();
console.log(cache); // {get: f,set: f}
cache.set("a", 1);
cache.get("a"); // 1
```

> 匿名函数创建了一个闭包，使 store 函数可以一直被引用。

弊端：持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外的手动清理机制。

### 高阶函数

函数式编程倾向于复用一组通用的函数功能来处理数据，它通过使用高阶函数来实现。
**高阶函数指一个函数以函数为参数，或以函数为返回值，或既以函数为参数又以函数为返回值。**

用途：

- 抽象或隔离行为、作用，异步控制流程作为回调函数，promises，monads 等。
- 创建可以用于各种数据类型的功能。
- 部分应用于函数参数或创建一个柯里化函数，用于复用或函数复合。
- 接受一个函数列表并返回一些由这个列表中的函数组成的复合函数。

例如：map、filter、reduce 都为高阶函数。

### 函数柯里化

柯里化又称部分求值，柯里化函数会接收一些参数，然后不会立即求值，而是继续返回一个新函数，将传入的参数通过闭包的形式保存，等到被真正求值时，再一次性的把所有传入的参数进行求值。

```js
// 普通函数
function add(x, y) {
  return x + y;
}
add(1, 2); // 3

// 函数柯里化
var add = function (x) {
  return function (y) {
    return x + y;
  };
};
var increment = add(1);
increment(2); // 3
```

> 定义了一个 add 函数，它接收一个参数并返回一个新的函数。调用 add 后，返回的函数就通过闭包的方式记住了 add 的第一个参数。

```js
// 实现一个简易的柯里化函数
function curryIt(fn) {
  // 参数fn函数的参数个数
  var n = fn.length;
  var args = [];
  return function (arg) {
    args.push(arg);
    if (args.length < n) {
      return arguments.callee; // 返回这个函数的引用
    } else {
      return fn.apply(this, args);
    }
  };
}
function add(a, b, c) {
  return [a, b, c];
}
var c = curryIt(add);
var c1 = c(1);
var c2 = c(2);
var c3 = c(3);
console.log(c3); // [1,2,3]
```

> 柯里化是一种“预加载”函数的方式，通过传递较少的参数，得到一个已经记住了这些参数的新函数，这是一种对参数的“缓存”，是一种非常高效的编写函数的方式。

### 函数组合

函数式编程的一个特点是：通过串联函数来求值。然而，随着串联函数数量的增多，代码的可读性就会不断下降。函数组合就是解决这个问题的。

假设有一个 compose 函数，它可以接受多个函数作为参数，然后返回一个新的函数。当我们为这个新函数传递参数时，该参数就会流过其中的函数，最后返回结果。

```js
// 两个函数的组合
var compose = function (f, g) {
  return function (x) {
    return f(g(x));
  };
};
// 或
var compose = (f, g) => (x) => f(g(x));
var add1 = (x) => x + 1;
var mul5 = (x) => x * 5;
compose(mul5, add1)(2); // 15
```
