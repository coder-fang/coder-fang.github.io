---
title: 深拷贝与浅拷贝
categories: 知识
date: 2022-12-01
updated: 2022-12-01
tags: [深拷贝, 浅拷贝]
cover: https://img0.baidu.com/it/u=3468195956,3684933571&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=399
---

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fda5b9d6e52347ffb00b2598925547e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

## 深拷贝

深拷贝：深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象（新旧对象不共享一块内存），且修改新对象不会影响原对象（深拷贝采用了在堆内存中申请新的空间来存储数据，这样每个可以避免指针悬挂）

> 对基本数据类型进行值传递，对引用类型，创建一个对象，并复制其内容。

特点:

- 对于基本数据类型的成员对象，直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响到另外一个（和浅拷贝一样）。
- 对于引用类型，比如数组或类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个产生影响（和浅拷贝不同）。
- 对于有多层对象的，每个对象都需要实现 Cloneable 并重写 clone()方法，进而实现了对象的串行层层拷贝。(在 Java 中)
- 深拷贝相比于浅拷贝速度较慢，而且花销较大。

## 浅拷贝

浅拷贝：如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址（新旧对象共享一块内存地址），所以如果其中一个对象改变了这个地址，就会影响到另一个对象（只是拷贝了指针，使得两个指针指向同一块地址，这样在对象块结束，调用函数析构时，会造成同一份资源析构 2 次，即 delete 同一块内存 2 次，造成程序崩溃。）

> 对基本数据类型进行值传递，对引用数据类型进行引用传递。

### 深拷贝和浅拷贝的区别

1. 浅拷贝和深拷贝都是创建一份数据的拷贝。
   JS 分为原始类型和引用类型，对于原始类型的拷贝，并没有深浅拷贝的区别。我们讨论深浅拷贝都只针对引用类型。

- 浅拷贝和深拷贝都复制了值和地址，都是为了解决引用类型赋值后的互相影响的问题。
- 但浅拷贝**只进行一层复制**，深层次的引用类型还是共享内存地址，源对象和拷贝对象还是会互相影响。
- 深拷贝就是**无限层级拷贝**，深拷贝后的源对象不会和拷贝对象互相影响。

### 赋值和浅拷贝的区别

- 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象在栈中的地址，而不是堆中的数据。也就是说，两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变存储空间的内容，因此，两个对象是联动的。
- 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有原始对象属性值的一份精切拷贝。
  如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制（逐个成员依次拷贝），即只复制对象空间而不复制资源。

### 引用类型互相赋值

直接赋值，两个对象指向同一地址，就会造成引用类型之间互相影响的问题。

```js
const obj = {
  name: "大酱",
};

const newObj = obj;
obj.name = "xxx"; // 改变原来的对象

console.log("原来的对象", obj);
console.log("新的对象", newObj);

console.log("两者指向同一地址", obj == newObj);
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b03c8dfda7484c44818de10ebfd78d43~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

## 浅拷贝的实现方式

### Object.assign()

Object.assign()可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。

```js
let obj1 = { person: { name: "kobe", age: 41 }, sports: "basketball" };
let obj2 = Object.assign({}, obj1);
obj2.person.name = "wade";
obj2.sports = "football";
console.log(obj1); // {person:{name:'wade',age: 41},sports:'basketball'}
```

### lodash 函数库的\_.clone 方法

```js
var _ = require("lodash");
var obj1 = {
  a: 1,
  b: { f: { g: 1 } },
  c: [1, 2, 3],
};
var obj2 = _.clone(obj1);
console.log(obj1.b.f === obj2.b.f); // true
```

### 扩展运算符...

扩展运算符是一个 es6/es2015 特性，与 Object.assign()功能相同。

> 深层浅拷贝，浅层深拷贝。

```js
let obj1 = { a: 1, b: { c: 1 } };
let obj2 = { ...obj1 };
obj1.a = 2;
obj1.b.c = 3;
console.log(obj1); // {a:2,b:{c:3}}
console.log(obj2); // {a:1,b:{c:3}}
```

### Array.prototype.concat()

```js
let arr = [1, 3, { username: "rose" }];
let arr2 = arr.concat();
arr2[2].username = "酱子";
console.log(arr); // [1,3,{username:'酱子'}]
```

### Array.prototype.slice()

```js
let arr = [1, 3, { username: "rose" }];
let arr3 = arr.slice();
arr3[2].username = "大酱";
console.log(arr); // [1,3,{username:'大酱'}]
```

## 深拷贝的实现方式

### JSON.parse(JSON.stringify())

```js
let arr = [1, 3, { username: "rose" }];
let arr4 = JSON.parse(JSON.stringify(arr));
arr4[2].username = "大酱";
console.log(arr, arr4); // arr:[1,3,{username:'rose'}]    arr4:[1,3,{username:'大酱'}] 结果不一样
```

这是利用 JSON.stringify()将对象转为 JSON 字符串，再用 JSON.parse()把字符串解析成对象，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。

注意：这种方法虽然可以实现数组或对象拷贝，**但不能处理函数和正则**，因为这两者基于 JSON.stringify 和 JSON.parse 处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数(变为 null)了。

例如：

```js
let arr = [
  1,
  3,
  {
    username: " kobe",
  },
  function () {},
];
let arr4 = JSON.parse(JSON.stringify(arr));
arr4[2].username = "duncan";
console.log(arr, arr4);
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/30/164e6daa14a1f8be~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

### lodash 函数库的\_.cloneDeep 方法

```js
var _ = require("lodash");
var obj1 = {
  a: 1,
  b: { f: { g: 1 } },
  c: [1, 2, 3],
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f); // false
```

### jQuery.extend()方法

```js
$.extend(deepCopy, target, object1, [objectN]); //第一个参数为true,就是深拷贝
```

```js
var $ = require("jquery");
var obj1 = {
  a: 1,
  b: { f: { g: 1 } },
  c: [1, 2, 3],
};
var obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f); // false
```

### 手写递归方法

递归方法实现深度克隆的原理：**遍历对象、数组直到里面都是基本数据类型，然后再去复制，就是深拷贝。**
注意：对象存在**循环引用**的情况，即对象的属性直接引用了自身。
解决（循环引用）办法：可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，是否拷贝过这个对象，如果有，直接返回；如果没有，继续拷贝。

```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
let obj = { name: 1, address: { x: 100 } };
obj.o = obj; // 对象存在循环引用的情况
let d = deepClone(obj);
obj.address.x = 200;
console.log(d);
```
